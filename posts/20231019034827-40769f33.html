<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试 | CJ's Blog</title><meta name="author" content="CJ"><meta name="copyright" content="CJ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试对待技术题的面试思路对于一个面试题的几个步骤需要知道。  联系项目。这个技术组件是在什么场景下用到的&#x2F;为什么用这个&#x2F;适用于什么场景 它的好处和坏处 调研。技术没有绝对的好坏，关键是怎么用。在用到的场景下，它与同类对比&#x2F;各适用于什么场景  如何设计一个高并发系统如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="https://cjchn.github.io/posts/20231019034827-40769f33.html">
<meta property="og:site_name" content="CJ&#39;s Blog">
<meta property="og:description" content="面试对待技术题的面试思路对于一个面试题的几个步骤需要知道。  联系项目。这个技术组件是在什么场景下用到的&#x2F;为什么用这个&#x2F;适用于什么场景 它的好处和坏处 调研。技术没有绝对的好坏，关键是怎么用。在用到的场景下，它与同类对比&#x2F;各适用于什么场景  如何设计一个高并发系统如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgcdn.319226.xyz/202401041503387.png">
<meta property="article:published_time" content="2023-10-19T03:48:27.000Z">
<meta property="article:modified_time" content="2024-01-04T08:19:42.765Z">
<meta property="article:author" content="CJ">
<meta property="article:tag" content="专题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgcdn.319226.xyz/202401041503387.png"><link rel="shortcut icon" href="https://imgcdn.319226.xyz/202401041503387.png"><link rel="canonical" href="https://cjchn.github.io/posts/20231019034827-40769f33.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"51DB2F26GB","apiKey":"1de06e184485e0844182c52de8afda82","indexName":"cjchn.github.io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-04 16:19:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://imgcdn.319226.xyz/202401041503387.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://dh.echs.top/cjcn.html"><i class="fa-fw fa-solid fa-location-arrow"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://status.319226.xyz/"><i class="fa-fw fa-brands fa-watchman-monitoring"></i><span> 监测</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="CJ's Blog"><span class="site-name">CJ's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://dh.echs.top/cjcn.html"><i class="fa-fw fa-solid fa-location-arrow"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://status.319226.xyz/"><i class="fa-fw fa-brands fa-watchman-monitoring"></i><span> 监测</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-19T03:48:27.000Z" title="发表于 2023-10-19 11:48:27">2023-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-04T08:19:42.765Z" title="更新于 2024-01-04 16:19:42">2024-01-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>91分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h3 id="对待技术题的面试思路"><a href="#对待技术题的面试思路" class="headerlink" title="对待技术题的面试思路"></a>对待技术题的面试思路</h3><p>对于一个面试题的几个步骤需要知道。</p>
<ol>
<li>联系项目。这个技术组件是在什么场景下用到的&#x2F;为什么用这个&#x2F;适用于什么场景</li>
<li>它的好处和坏处</li>
<li>调研。技术没有绝对的好坏，关键是怎么用。在用到的场景下，它与同类对比&#x2F;各适用于什么场景</li>
</ol>
<h2 id="如何设计一个高并发系统"><a href="#如何设计一个高并发系统" class="headerlink" title="如何设计一个高并发系统"></a>如何设计一个高并发系统</h2><p>如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，<strong>一定是因为你实际上没干过高并发系统</strong>。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。</p>
<p>其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？</p>
<p>我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。你数据库如果瞬间承载每秒 5000&#x2F;8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。</p>
<p>所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。</p>
<p>那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：</p>
<p>可以分为以下 6 点：</p>
<ul>
<li>系统拆分</li>
<li>缓存</li>
<li>MQ</li>
<li>分库分表</li>
<li>读写分离</li>
<li>ElasticSearch</li>
</ul>
<p><img src="https://tgph.319226.xyz/file/cc3840e5f74b8088ac65f.png" alt="high-concurrency-system-design.png"></p>
<h4 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h4><p>将一个系统拆分为多个子系统，用 dubbo 来搞。也可以不用，但是http 接口通信维护起来成本很高，你要考虑<strong>超时重试</strong>、<strong>负载均衡</strong>等等各种乱七八糟的问题。dubbo 说白了，是一种 rpc 框架，就是说本地就是进行接口调用，但是 dubbo 会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡、服务实例上下线自动感知、超时重试等等乱七八糟的问题。那你就不用自己做了，用 dubbo 就可以了。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p>
<h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p>
<h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p>
<p>上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p>
<p>说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p>
<p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p>
<h2 id="分布式系统-CAP-定理-P-代表什么含义"><a href="#分布式系统-CAP-定理-P-代表什么含义" class="headerlink" title="分布式系统 CAP 定理 P 代表什么含义"></a>分布式系统 CAP 定理 P 代表什么含义</h2><p>在看 CAP 定理时抱有很大的疑惑，CAP 定理的定义是指在分布式系统中三者只能满足其二，也就是存在分布式 CA 系统的。作者在网络上查阅了很多关于 CAP 文章，虽然这些文章对于 P 的解释五花八门，但总结下来这些观点大多都是指 P 是不可缺少的，也就是说在分布式系统只能是 AP 或者 CP，这种理论与我之前所认识的理论（存在分布式 CA 系统）是冲突的，所以才有了疑惑。</p>
<h3 id="什么是-CAP-定理（CAP-theorem）"><a href="#什么是-CAP-定理（CAP-theorem）" class="headerlink" title="什么是 CAP 定理（CAP theorem）"></a>什么是 CAP 定理（CAP theorem）</h3><p>在理论计算机科学中，CAP 定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。）</li>
</ul>
<h3 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h3><p>理解 CAP 理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质。除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质。</p>
<ul>
<li>P 指的是分区容错性，分区现象产生后需要容错，容错是指在 A 与 C 之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性 P。</li>
<li>无论我设计的系统是 AP 还是 CP 系统如果没有出现不一致不可用。 则该系统就处于 CA 状态</li>
<li>P 的体现前提是得有分区情况存在</li>
</ul>
<p>文章来源：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">维基百科 CAP 定理</a></p>
<h3 id="几个常用的-CAP-框架对比"><a href="#几个常用的-CAP-框架对比" class="headerlink" title="几个常用的 CAP 框架对比"></a>几个常用的 CAP 框架对比</h3><table>
<thead>
<tr>
<th>框架</th>
<th>所属</th>
</tr>
</thead>
<tbody><tr>
<td>Eureka</td>
<td>AP</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>CP</td>
</tr>
<tr>
<td>Consul</td>
<td>CP</td>
</tr>
</tbody></table>
<h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><blockquote>
<p>Eureka 保证了可用性，实现最终一致性。</p>
</blockquote>
<p>Eureka 所有节点都是平等的所有数据都是相同的，且 Eureka 可以相互交叉注册。<br>Eureka client 使用内置轮询负载均衡器去注册，有一个检测间隔时间，如果在一定时间内没有收到心跳，才会移除该节点注册信息；如果客户端发现当前 Eureka 不可用，会切换到其他的节点，如果所有的 Eureka 都跪了，Eureka client 会使用最后一次数据作为本地缓存；所以以上的每种设计都是他不具备<code>一致性</code>的特性。</p>
<p>注意：因为 EurekaAP 的特性和请求间隔同步机制，在服务更新时候一般会手动通过 Eureka 的 api 把当前服务状态设置为<code>offline</code>，并等待 2 个同步间隔后重新启动，这样就能保证服务更新节点对整体系统的影响</p>
<h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><blockquote>
<p>强一致性</p>
</blockquote>
<p>Zookeeper 在选举 leader 时会停止服务，只有成功选举 leader 成功后才能提供服务，选举时间较长；内部使用 paxos 选举投票机制，只有获取半数以上的投票才能成为 leader，否则重新投票，所以部署的时候最好集群节点不小于 3 的奇数个（但是谁能保证跪掉后节点也是奇数个呢）；Zookeeper 健康检查一般是使用 tcp 长链接，在内部网络抖动时或者对应节点阻塞时候都会变成不可用，这里还是比较危险的；</p>
<h4 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h4><p>和 Zookeeper 一样数据 CP</p>
<p>Consul 注册时候只有过半的节点都写入成功才认为注册成功；leader 挂掉时，重新选举期间整个 Consul 不可用,保证了强一致性但牺牲了可用性<br>有很多 blog 说 Consul 属于 ap，官方已经确认他为 CP 机制 原文地址：<a target="_blank" rel="noopener" href="https://www.consul.io/docs/intro/vs/serf">https://www.consul.io/docs/intro/vs/serf</a></p>
<h2 id="分布式锁如何设计"><a href="#分布式锁如何设计" class="headerlink" title="分布式锁如何设计"></a>分布式锁如何设计</h2><p>其实一般问问题，都是这么问的，先问问你 zk，然后其实是要过渡到 zk 相关的一些问题里去，比如分布式锁。因为在分布式系统开发中，分布式锁的使用场景还是很常见的。</p>
<h3 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h3><p>官方叫做 <code>RedLock</code> 算法，是 Redis 官方支持的分布式锁算法。</p>
<p>这个分布式锁有 3 个重要的考量点：</p>
<ul>
<li>互斥（只能有一个客户端获取锁）</li>
<li>不能死锁</li>
<li>容错（只要大部分 Redis 节点创建了这把锁就可以）</li>
</ul>
<h3 id="Redis-最普通的分布式锁"><a href="#Redis-最普通的分布式锁" class="headerlink" title="Redis 最普通的分布式锁"></a>Redis 最普通的分布式锁</h3><p>第一个最普通的实现方式，就是在 Redis 里使用 <code>SET key value [EX seconds] [PX milliseconds] NX</code> 创建一个 key，这样就算加锁。其中：</p>
<ul>
<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功，如果此时 redis 中存在这个 <code>key</code>，那么设置失败，返回 <code>nil</code>。</li>
<li><code>EX seconds</code>：设置 <code>key</code> 的过期时间，精确到秒级。意思是 <code>seconds</code> 秒后锁自动释放，别人创建的时候如果发现已经有了就不能加锁了。</li>
<li><code>PX milliseconds</code>：同样是设置 <code>key</code> 的过期时间，精确到毫秒级。</li>
</ul>
<p>比如执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value PX 30000 NX</span><br></pre></td></tr></table></figure>

<p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>为啥要用 <code>random_value</code> 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 <code>lua</code> 脚本来释放锁。</p>
<p>但是这样是肯定不行的。因为如果是普通的 Redis 单实例，那就是单点故障。或者是 Redis 普通主从，那 Redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。</p>
<h3 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h3><p>这个场景是假设有一个 Redis cluster，有 5 个 Redis master 实例。然后执行如下步骤获取一把锁：</p>
<ol>
<li>获取当前时间戳，单位是毫秒；</li>
<li>跟上面类似，轮流尝试在每个 master 节点上创建锁，超时时间较短，一般就几十毫秒（客户端为了获取锁而使用的超时时间比自动释放锁的总时间要小。例如，如果自动释放时间是 10 秒，那么超时时间可能在 <code>5~50</code> 毫秒范围内）；</li>
<li>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code> ；</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li>
<li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li>
<li>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</li>
</ol>
<p><img src="https://tgph.319226.xyz/file/e8bf1e7ec038c547f165d.png" alt="redis-redlock"></p>
<p><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官方</a>给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a> 。</p>
<h3 id="zk-分布式锁"><a href="#zk-分布式锁" class="headerlink" title="zk 分布式锁"></a>zk 分布式锁</h3><p>zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能<strong>注册个监听器</strong>监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ZooKeeperSession</span><br><span class="line"> */</span><br><span class="line">public class ZooKeeperSession &#123;</span><br><span class="line"></span><br><span class="line">    private static CountDownLatch connectedSemaphore = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    private ZooKeeper zookeeper;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    public ZooKeeperSession() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.zookeeper = new ZooKeeper(&quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;, 50000, new ZooKeeperWatcher());</span><br><span class="line">            try &#123;</span><br><span class="line">                connectedSemaphore.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;ZooKeeper session established......&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取分布式锁</span><br><span class="line">     *</span><br><span class="line">     * @param productId</span><br><span class="line">     */</span><br><span class="line">    public Boolean acquireDistributedLock(Long productId) &#123;</span><br><span class="line">        String path = &quot;/product-lock-&quot; + productId;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            zookeeper.create(path, &quot;&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 相当于是给node注册一个监听器，去看看这个监听器是否存在</span><br><span class="line">                    Stat stat = zk.exists(path, true);</span><br><span class="line"></span><br><span class="line">                    if (stat != null) &#123;</span><br><span class="line">                        this.latch = new CountDownLatch(1);</span><br><span class="line">                        this.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        this.latch = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, &quot;&quot;.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; catch (Exception ee) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放掉一个分布式锁</span><br><span class="line">     *</span><br><span class="line">     * @param productId</span><br><span class="line">     */</span><br><span class="line">    public void releaseDistributedLock(Long productId) &#123;</span><br><span class="line">        String path = &quot;/product-lock-&quot; + productId;</span><br><span class="line">        try &#123;</span><br><span class="line">            zookeeper.delete(path, -1);</span><br><span class="line">            System.out.println(&quot;release the lock for product[id=&quot; + productId + &quot;]......&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 建立 zk session 的 watcher</span><br><span class="line">     */</span><br><span class="line">    private class ZooKeeperWatcher implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">        public void process(WatchedEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;Receive watched event: &quot; + event.getState());</span><br><span class="line"></span><br><span class="line">            if (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (this.latch != null) &#123;</span><br><span class="line">                this.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 封装单例的静态内部类</span><br><span class="line">     */</span><br><span class="line">    private static class Singleton &#123;</span><br><span class="line"></span><br><span class="line">        private static ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            instance = new ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static ZooKeeperSession getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取单例</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ZooKeeperSession getInstance() &#123;</span><br><span class="line">        return Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化单例的便捷方法</span><br><span class="line">     */</span><br><span class="line">    public static void init() &#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以采用另一种方式，创建临时顺序节点：</p>
<p>如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 ZooKeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public class ZooKeeperDistributedLock implements Watcher &#123;</span><br><span class="line"></span><br><span class="line">    private ZooKeeper zk;</span><br><span class="line">    private String locksRoot = &quot;/locks&quot;;</span><br><span class="line">    private String productId;</span><br><span class="line">    private String waitNode;</span><br><span class="line">    private String lockNode;</span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line">    private CountDownLatch connectedLatch = new CountDownLatch(1);</span><br><span class="line">    private int sessionTimeout = 30000;</span><br><span class="line"></span><br><span class="line">    public ZooKeeperDistributedLock(String productId) &#123;</span><br><span class="line">        this.productId = productId;</span><br><span class="line">        try &#123;</span><br><span class="line">            String address = &quot;192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181&quot;;</span><br><span class="line">            zk = new ZooKeeper(address, sessionTimeout, this);</span><br><span class="line">            connectedLatch.await();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void process(WatchedEvent event) &#123;</span><br><span class="line">        if (event.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.latch != null) &#123;</span><br><span class="line">            this.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void acquireDistributedLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.tryLock()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 传入进去的locksRoot + “/” + productId</span><br><span class="line">            // 假设productId代表了一个商品id，比如说1</span><br><span class="line">            // locksRoot = locks</span><br><span class="line">            // /locks/10000000000，/locks/10000000001，/locks/10000000002</span><br><span class="line">            lockNode = zk.create(locksRoot + &quot;/&quot; + productId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            // 看看刚创建的节点是不是最小的节点</span><br><span class="line">            // locks：10000000000，10000000001，10000000002</span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, false);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            if (lockNode.equals(locksRoot + &quot;/&quot; + locks.get(0))) &#123;</span><br><span class="line">                // 如果是最小的节点,则表示取得锁</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果不是最小的节点，找到比自己小1的节点</span><br><span class="line">            int previousLockIndex = -1;</span><br><span class="line">            for (int i = 0; i &lt; locks.size(); i++) &#123;</span><br><span class="line">                if (lockNode.equals(locksRoot + &quot;/&quot; +locks.get(i)))&#123;</span><br><span class="line">                    previousLockIndex = i - 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.waitNode = locks.get(previousLockIndex);</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean waitForLock(String waitNode, long waitTime) throws InterruptedException, KeeperException &#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + &quot;/&quot; + waitNode, true);</span><br><span class="line">        if (stat != null) &#123;</span><br><span class="line">            this.latch = new CountDownLatch(1);</span><br><span class="line">            this.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            this.latch = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 删除/locks/10000000000节点</span><br><span class="line">            // 删除/locks/10000000001节点</span><br><span class="line">            System.out.println(&quot;unlock &quot; + lockNode);</span><br><span class="line">            zk.delete(lockNode, -1);</span><br><span class="line">            lockNode = null;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class LockException extends RuntimeException &#123;</span><br><span class="line">        private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">        public LockException(String e) &#123;</span><br><span class="line">            super(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public LockException(Exception e) &#123;</span><br><span class="line">            super(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，使用 zk 临时节点会存在另一个问题：由于 zk 依靠 session 定期的心跳来维持客户端，如果客户端进入长时间的 GC，可能会导致 zk 认为客户端宕机而释放锁，让其他的客户端获取锁，但是客户端在 GC 恢复后，会认为自己还持有锁，从而可能出现多个客户端同时获取到锁的情形。<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/issues/209">#209</a></p>
<p>针对这种情况，可以通过 JVM 调优，尽量避免长时间 GC 的情况发生。</p>
<h3 id="redis-分布式锁和-zk-分布式锁的对比"><a href="#redis-分布式锁和-zk-分布式锁的对比" class="headerlink" title="redis 分布式锁和 zk 分布式锁的对比"></a>redis 分布式锁和 zk 分布式锁的对比</h3><ul>
<li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li>
<li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li>
</ul>
<p>另外一点就是，如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</p>
<p>Redis 分布式锁大家没发现好麻烦吗？遍历上锁，计算时间等等……zk 的分布式锁语义清晰实现简单。</p>
<p>所以先不分析太多的东西，就说这两点，我个人实践认为 zk 的分布式锁比 Redis 的分布式锁牢靠、而且模型简单易用。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>只要聊到你做了分布式系统，必问分布式事务，你对分布式事务一无所知的话，确实会很坑，你起码得知道有哪些方案，一般怎么来做，每个方案的优缺点是什么。</p>
<p>现在面试，分布式系统成了标配，而分布式系统带来的<strong>分布式事务</strong>也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。</p>
<p>分布式事务的实现主要有以下 6 种方案：</p>
<ul>
<li>XA 方案</li>
<li>TCC 方案</li>
<li>SAGA 方案</li>
<li>本地消息表</li>
<li>可靠消息最终一致性方案</li>
<li>最大努力通知方案</li>
</ul>
<h3 id="两阶段提交方案-XA-方案"><a href="#两阶段提交方案-XA-方案" class="headerlink" title="两阶段提交方案&#x2F;XA 方案"></a>两阶段提交方案&#x2F;XA 方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p>
<p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 <code>Spring + JTA</code> 就可以搞定，自己随便搜个 demo 看看就知道了。</p>
<p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p>
<p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p>
<p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p>
<p><img src="https://tgph.319226.xyz/file/b6d29b481b62839155423.png" alt="distributed-transacion-XA"></p>
<h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>TCC 的全称是： <code>Try</code> 、 <code>Confirm</code> 、 <code>Cancel</code> 。</p>
<ul>
<li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li>
<li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li>
<li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li>
</ul>
<p>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个<strong>事务回滚</strong>实际上是<strong>严重依赖于你自己写代码来回滚和补偿</strong>了，会造成补偿代码巨大，非常之恶心。</p>
<p>比如说我们，一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付</strong>、<strong>交易</strong>相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p>
<p>而且最好是你的各个业务执行的时间都比较短。</p>
<p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p>
<p><img src="https://tgph.319226.xyz/file/c4b09a5ef39c62084b7c0.png" alt="distributed-transacion-TCC"></p>
<h3 id="Saga-方案"><a href="#Saga-方案" class="headerlink" title="Saga 方案"></a>Saga 方案</h3><p>金融核心等业务可能会选择 TCC 方案，以追求强一致性和更高的并发量，而对于更多的金融核心以上的业务系统 往往会选择补偿事务，补偿事务处理在 30 多年前就提出了 Saga 理论，随着微服务的发展，近些年才逐步受到大家的关注。目前业界比较公认的是采用 Saga 作为长事务的解决方案。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>业务流程中每个参与者都提交本地事务，若某一个参与者失败，则补偿前面已经成功的参与者。下图左侧是正常的事务流程，当执行到 T3 时发生了错误，则开始执行右边的事务补偿流程，反向执行 T3、T2、T1 的补偿服务 C3、C2、C1，将 T3、T2、T1 已经修改的数据补偿掉。</p>
<p><img src="https://tgph.319226.xyz/file/abcf61f41efb474c3598e.png" alt="distributed-transacion-TCC"></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>对于一致性要求高、短流程、并发高 的场景，如：金融核心系统，会优先考虑 TCC 方案。而在另外一些场景下，我们并不需要这么强的一致性，只需要保证最终一致性即可。</p>
<p>比如 很多金融核心以上的业务（渠道层、产品层、系统集成层），这些系统的特点是最终一致即可、流程多、流程长、还可能要调用其它公司的服务。这种情况如果选择 TCC 方案开发的话，一来成本高，二来无法要求其它公司的服务也遵循 TCC 模式。同时流程长，事务边界太长，加锁时间长，也会影响并发性能。</p>
<p>所以 Saga 模式的适用场景是：</p>
<ul>
<li>业务流程长、业务流程多；</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>一阶段提交本地事务，无锁，高性能；</li>
<li>参与者可异步执行，高吞吐；</li>
<li>补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不保证事务的隔离性。</li>
</ul>
<h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p>
<p>这个大概意思是这样的：</p>
<ol>
<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>
<li>接着 A 系统将这个消息发送到 MQ 中去；</li>
<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；</li>
<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>
<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>
<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li>
</ol>
<p>这个方案说实话最大的问题就在于<strong>严重依赖于数据库的消息表来管理事务</strong>啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p>
<p><img src="https://tgph.319226.xyz/file/11daee3b5015da2b84a5b.png" alt="distributed-transaction-local-message-table"></p>
<h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p>
<p>大概的意思就是：</p>
<ol>
<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li>
<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>
<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>
<li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>
<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li>
<li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你就用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li>
</ol>
<p><img src="https://tgph.319226.xyz/file/634c723922434ccf8fd16.png" alt="distributed-transaction-reliable-message"></p>
<h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>这个方案的大致意思就是：</p>
<ol>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li>
<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li>
</ol>
<h3 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h3><p>如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p>
<p>你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p>
<p>友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p>
<p>当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p>
<h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><p>面试官问了你一堆 Dubbo 是怎么玩儿的，你会玩儿 Dubbo 就可以把单块系统弄成分布式系统，然后分布式之后接踵而来的就是一堆问题，最大的问题就是<strong>分布式事务</strong>、<strong>接口幂等性</strong>、<strong>分布式锁</strong>，还有最后一个就是<strong>分布式 Session</strong>。</p>
<p>当然了，分布式系统中的问题何止这么一点，非常之多，复杂度很高，这里只是说一下常见的几个问题，也是面试的时候常问的几个。</p>
<h3 id="集群部署时的分布式-Session-如何实现？"><a href="#集群部署时的分布式-Session-如何实现？" class="headerlink" title="集群部署时的分布式 Session 如何实现？"></a>集群部署时的分布式 Session 如何实现？</h3><p>Session 是啥？浏览器有个 Cookie，在一段时间内这个 Cookie 都存在，然后每次发请求过来都带上一个特殊的 <code>jsessionid cookie</code> ，就根据这个东西，在服务端可以维护一个对应的 Session 域，里面可以放点数据。</p>
<p>一般的话只要你没关掉浏览器，Cookie 还在，那么对应的那个 Session 就在，但是如果 Cookie 没了，Session 也就没了。常见于什么购物车之类的东西，还有登录状态保存之类的。</p>
<p>这个不多说了，懂 Java 的都该知道这个。</p>
<p>单块系统的时候这么玩儿 Session 没问题，但是你要是分布式系统呢，那么多的服务，Session 状态在哪儿维护啊？</p>
<p>其实方法很多，但是常见常用的是以下几种：</p>
<h3 id="完全不用-Session"><a href="#完全不用-Session" class="headerlink" title="完全不用 Session"></a>完全不用 Session</h3><p>使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。</p>
<h3 id="Tomcat-Redis"><a href="#Tomcat-Redis" class="headerlink" title="Tomcat + Redis"></a>Tomcat + Redis</h3><p>这个其实还挺方便的，就是使用 Session 的代码，跟以前一样，还是基于 Tomcat 原生的 Session 支持即可，然后就是用一个叫做 <code>Tomcat RedisSessionManager</code> 的东西，让所有我们部署的 Tomcat 都将 Session 数据存储到 Redis 即可。</p>
<p>在 Tomcat 的配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span><br><span class="line">         host=&quot;&#123;redis.host&#125;&quot;</span><br><span class="line">         port=&quot;&#123;redis.port&#125;&quot;</span><br><span class="line">         database=&quot;&#123;redis.dbnum&#125;&quot;</span><br><span class="line">         maxInactiveInterval=&quot;60&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>然后指定 Redis 的 host 和 port 就 ok 了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; /&gt;</span><br><span class="line">&lt;Manager className=&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span><br><span class="line">     sentinelMaster=&quot;mymaster&quot;</span><br><span class="line">     sentinels=&quot;&lt;sentinel1-ip&gt;:26379,&lt;sentinel2-ip&gt;:26379,&lt;sentinel3-ip&gt;:26379&quot;</span><br><span class="line">     maxInactiveInterval=&quot;60&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>还可以用上面这种方式基于 Redis 哨兵支持的 Redis 高可用集群来保存 Session 数据，都是 ok 的。</p>
<h3 id="Spring-Session-Redis"><a href="#Spring-Session-Redis" class="headerlink" title="Spring Session + Redis"></a>Spring Session + Redis</h3><p>上面所说的第二种方式会与 Tomcat 容器重耦合，如果我要将 Web 容器迁移成 Jetty，难道还要重新把 Jetty 都配置一遍？</p>
<p>因为上面那种 Tomcat + Redis 的方式好用，但是会<strong>严重依赖于 Web 容器</strong>，不好将代码移植到其他 Web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 Spring Cloud 或者是 Spring Boot 之类的呢？</p>
<p>所以现在比较好的还是基于 Java 一站式解决方案，也就是 Spring。人家 Spring 基本上承包了大部分我们需要使用的框架，Spirng Cloud 做微服务，Spring Boot 做脚手架，所以用 Spring Session 是一个很好的选择。</p>
<p>在 pom.xml 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.8.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在 Spring 配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;redisHttpSessionConfiguration&quot;</span><br><span class="line">     class=&quot;org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;maxInactiveIntervalInSeconds&quot; value=&quot;600&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;maxTotal&quot; value=&quot;100&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;jedisConnectionFactory&quot;</span><br><span class="line">      class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis_hostname&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;port&quot; value=&quot;$&#123;redis_port&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;redis_pwd&#125;&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;timeout&quot; value=&quot;3000&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;usePool&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>在 web.xml 中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/test&quot;)</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/putIntoSession&quot;)</span><br><span class="line">    public String putIntoSession(HttpServletRequest request, String username) &#123;</span><br><span class="line">        request.getSession().setAttribute(&quot;name&quot;,  &quot;leo&quot;);</span><br><span class="line">        return &quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/getFromSession&quot;)</span><br><span class="line">    public String getFromSession(HttpServletRequest request, Model model)&#123;</span><br><span class="line">        String name = request.getSession().getAttribute(&quot;name&quot;);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是 ok 的，给 Spring Session 配置基于 Redis 来存储 Session 数据，然后配置了一个 Spring Session 的过滤器，这样的话，Session 相关操作都会交给 Spring Session 来管了。接着在代码中，就用原生的 Session 操作，就是直接基于 Spring Session 从 Redis 中获取数据了。</p>
<p>实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，Tomcat + Redis 早期比较常用，但是会重耦合到 Tomcat 中；近些年，通过 Spring Session 来实现。</p>
<h2 id="如何限流？在工作中是怎么做的？说一下具体的实现？"><a href="#如何限流？在工作中是怎么做的？说一下具体的实现？" class="headerlink" title="如何限流？在工作中是怎么做的？说一下具体的实现？"></a>如何限流？在工作中是怎么做的？说一下具体的实现？</h2><h3 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流"></a>什么是限流</h3><p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。</p>
<h3 id="限流方法"><a href="#限流方法" class="headerlink" title="限流方法"></a>限流方法</h3><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>控制单位时间内的请求数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Counter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 最大访问数量</span><br><span class="line">     */</span><br><span class="line">    private final int limit = 10;</span><br><span class="line">    /**</span><br><span class="line">     * 访问时间差</span><br><span class="line">     */</span><br><span class="line">    private final long timeout = 1000;</span><br><span class="line">    /**</span><br><span class="line">     * 请求时间</span><br><span class="line">     */</span><br><span class="line">    private long time;</span><br><span class="line">    /**</span><br><span class="line">     * 当前计数器</span><br><span class="line">     */</span><br><span class="line">    private AtomicInteger reqCount = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public boolean limit() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        if (now &lt; time + timeout) &#123;</span><br><span class="line">            // 单位时间内</span><br><span class="line">            reqCount.addAndGet(1);</span><br><span class="line">            return reqCount.get() &lt;= limit;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 超出单位时间</span><br><span class="line">            time = now;</span><br><span class="line">            reqCount = new AtomicInteger(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>劣势：</p>
<p>假设在 00:01 时发生一个请求，在 00:01-00:58 之间不在发送请求，在 00:59 时发送剩下的所有请求 <code>n-1</code> (n 为限流请求数量)，在下一分钟的 00:01 发送 n 个请求，这样在 2 秒钟内请求到达了 <code>2n - 1</code> 个。</p>
<p>设每分钟请求数量为 60 个，每秒可以处理 1 个请求，用户在 00:59 发送 60 个请求，在 01:00 发送 60 个请求 此时 2 秒钟有 120 个请求(每秒 60 个请求)，远远大于了每秒钟处理数量的阈值。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口是对计数器方式的改进，增加一个时间粒度的度量单位，把一分钟分成若干等分(6 份，每份 10 秒)，在每一份上设置独立计数器，在 00:00-00:09 之间发生请求计数器累加 1。当等分数量越大限流统计就越详细。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo1.service;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line">import java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line">public class TimeWindow &#123;</span><br><span class="line">    private ConcurrentLinkedQueue&lt;Long&gt; queue = new ConcurrentLinkedQueue&lt;Long&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 间隔秒数</span><br><span class="line">     */</span><br><span class="line">    private int seconds;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最大限流</span><br><span class="line">     */</span><br><span class="line">    private int max;</span><br><span class="line"></span><br><span class="line">    public TimeWindow(int max， int seconds) &#123;</span><br><span class="line">        this.seconds = seconds;</span><br><span class="line">        this.max = max;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 永续线程执行清理queue 任务</span><br><span class="line">         */</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 等待 间隔秒数-1 执行清理操作</span><br><span class="line">                    Thread.sleep((seconds - 1) * 1000L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                clean();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        final TimeWindow timeWindow = new TimeWindow(10， 1);</span><br><span class="line"></span><br><span class="line">        // 测试3个线程</span><br><span class="line">        IntStream.range(0， 3).forEach((i) -&gt; &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                while (true) &#123;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(new Random().nextInt(20) * 100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    timeWindow.take();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取令牌，并且添加时间</span><br><span class="line">     */</span><br><span class="line">    public void take() &#123;</span><br><span class="line"></span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            int size = sizeOfValid();</span><br><span class="line">            if (size &gt; max) &#123;</span><br><span class="line">                System.err.println(&quot;超限&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (queue) &#123;</span><br><span class="line">                if (sizeOfValid() &gt; max) &#123;</span><br><span class="line">                    System.err.println(&quot;超限&quot;);</span><br><span class="line">                    System.err.println(&quot;queue中有 &quot; + queue.size() + &quot; 最大数量 &quot; + max);</span><br><span class="line">                &#125;</span><br><span class="line">                this.queue.offer(System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;queue中有 &quot; + queue.size() + &quot; 最大数量 &quot; + max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int sizeOfValid() &#123;</span><br><span class="line">        Iterator&lt;Long&gt; it = queue.iterator();</span><br><span class="line">        Long ms = System.currentTimeMillis() - seconds * 1000;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            long t = it.next();</span><br><span class="line">            if (t &gt; ms) &#123;</span><br><span class="line">                // 在当前的统计时间范围内</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 清理过期的时间</span><br><span class="line">     */</span><br><span class="line">    public void clean() &#123;</span><br><span class="line">        Long c = System.currentTimeMillis() - seconds * 1000;</span><br><span class="line"></span><br><span class="line">        Long tl = null;</span><br><span class="line">        while ((tl = queue.peek()) != null &amp;&amp; tl &lt; c) &#123;</span><br><span class="line">            System.out.println(&quot;清理数据&quot;);</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Leaky-Bucket-漏桶"><a href="#Leaky-Bucket-漏桶" class="headerlink" title="Leaky Bucket 漏桶"></a>Leaky Bucket 漏桶</h4><p>规定固定容量的桶，有水进入，有水流出。对于流进的水我们无法估计进来的数量、速度，对于流出的水我们可以控制速度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LeakBucket &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 时间</span><br><span class="line">     */</span><br><span class="line">    private long time;</span><br><span class="line">    /**</span><br><span class="line">     * 总量</span><br><span class="line">     */</span><br><span class="line">    private Double total;</span><br><span class="line">    /**</span><br><span class="line">     * 水流出去的速度</span><br><span class="line">     */</span><br><span class="line">    private Double rate;</span><br><span class="line">    /**</span><br><span class="line">     * 当前总量</span><br><span class="line">     */</span><br><span class="line">    private Double nowSize;</span><br><span class="line"></span><br><span class="line">    public boolean limit() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.max(0， (nowSize - (now - time) * rate));</span><br><span class="line">        time = now;</span><br><span class="line">        if ((nowSize + 1) &lt; total) &#123;</span><br><span class="line">            nowSize++;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Token-Bucket-令牌桶"><a href="#Token-Bucket-令牌桶" class="headerlink" title="Token Bucket 令牌桶"></a>Token Bucket 令牌桶</h4><p>规定固定容量的桶， token 以固定速度往桶内填充， 当桶满时 token 不会被继续放入， 每过来一个请求把 token 从桶中移除， 如果桶中没有 token 不能请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TokenBucket &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 时间</span><br><span class="line">     */</span><br><span class="line">    private long time;</span><br><span class="line">    /**</span><br><span class="line">     * 总量</span><br><span class="line">     */</span><br><span class="line">    private Double total;</span><br><span class="line">    /**</span><br><span class="line">     * token 放入速度</span><br><span class="line">     */</span><br><span class="line">    private Double rate;</span><br><span class="line">    /**</span><br><span class="line">     * 当前总量</span><br><span class="line">     */</span><br><span class="line">    private Double nowSize;</span><br><span class="line"></span><br><span class="line">    public boolean limit() &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        nowSize = Math.min(total， nowSize + (now - time) * rate);</span><br><span class="line">        time = now;</span><br><span class="line">        if (nowSize &lt; 1) &#123;</span><br><span class="line">            // 桶里没有token</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 存在token</span><br><span class="line">            nowSize -= 1;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作中的使用"><a href="#工作中的使用" class="headerlink" title="工作中的使用"></a>工作中的使用</h3><h4 id="spring-cloud-gateway"><a href="#spring-cloud-gateway" class="headerlink" title="spring cloud gateway"></a>spring cloud gateway</h4><ul>
<li>spring cloud gateway 默认使用 redis 进行限流，笔者一般只是修改修改参数属于拿来即用，并没有去从头实现上述那些算法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        gateway:</span><br><span class="line">            routes:</span><br><span class="line">                - id: requestratelimiter_route</span><br><span class="line"></span><br><span class="line">                  uri: lb://pigx-upms</span><br><span class="line">                  order: 10000</span><br><span class="line">                  predicates:</span><br><span class="line">                      - Path=/admin/**</span><br><span class="line"></span><br><span class="line">                  filters:</span><br><span class="line">                      - name: RequestRateLimiter</span><br><span class="line"></span><br><span class="line">                        args:</span><br><span class="line">                            redis-rate-limiter.replenishRate: 1 # 令牌桶的容积</span><br><span class="line">                            redis-rate-limiter.burstCapacity: 3 # 流速 每秒</span><br><span class="line">                            key-resolver: &#x27;#&#123;@remoteAddrKeyResolver&#125;&#x27; #SPEL表达式去的对应的bean</span><br><span class="line"></span><br><span class="line">                      - StripPrefix=1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">KeyResolver remoteAddrKeyResolver() &#123;</span><br><span class="line">    return exchange -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h4><ul>
<li>通过配置来控制每个 url 的流量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            discovery:</span><br><span class="line">                server-addr: localhost:8848</span><br><span class="line">        sentinel:</span><br><span class="line">            transport:</span><br><span class="line">                dashboard: localhost:8080</span><br><span class="line">                port: 8720</span><br><span class="line">            datasource:</span><br><span class="line">                ds:</span><br><span class="line">                    nacos:</span><br><span class="line">                        server-addr: localhost:8848</span><br><span class="line">                        dataId: spring-cloud-sentinel-nacos</span><br><span class="line">                        groupId: DEFAULT_GROUP</span><br><span class="line">                        rule-type: flow</span><br><span class="line">                        namespace: xxxxxxxx</span><br></pre></td></tr></table></figure>

<ul>
<li>配置内容在 nacos 上进行编辑</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;resource&quot;: &quot;/hello&quot;,</span><br><span class="line">        &quot;limitApp&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;grade&quot;: 1,</span><br><span class="line">        &quot;count&quot;: 1,</span><br><span class="line">        &quot;strategy&quot;: 0,</span><br><span class="line">        &quot;controlBehavior&quot;: 0,</span><br><span class="line">        &quot;clusterMode&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>resource：资源名，即限流规则的作用对象。</li>
<li>limitApp：流控针对的调用来源，若为 default 则不区分调用来源。</li>
<li>grade：限流阈值类型，QPS 或线程数模式，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。</li>
<li>count：限流阈值</li>
<li>strategy：判断的根据是资源自身，还是根据其它关联资源 (refResource)，还是根据链路入口</li>
<li>controlBehavior：流控效果（直接拒绝 &#x2F; 排队等待 &#x2F; 慢启动模式）</li>
<li>clusterMode：是否为集群模式</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>sentinel 和 spring cloud gateway 两个框架都是很好的限流框架， 但是在我使用中还没有将<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba">spring-cloud-alibaba</a>接入到项目中进行使用， 所以我会选择<strong>spring cloud gateway</strong>， 当接入完整的或者接入 Nacos 项目使用 setinel 会有更加好的体验.</p>
</blockquote>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><h3 id="如何进行熔断？"><a href="#如何进行熔断？" class="headerlink" title="如何进行熔断？"></a>如何进行熔断？</h3><p>&#x2F;&#x2F; todo</p>
<h3 id="熔断框架都有哪些？具体实现原理知道吗？"><a href="#熔断框架都有哪些？具体实现原理知道吗？" class="headerlink" title="熔断框架都有哪些？具体实现原理知道吗？"></a>熔断框架都有哪些？具体实现原理知道吗？</h3><p>&#x2F;&#x2F; todo</p>
<h3 id="如何做技术选型？Sentinel-还是-Hystrix？"><a href="#如何做技术选型？Sentinel-还是-Hystrix？" class="headerlink" title="如何做技术选型？Sentinel 还是 Hystrix？"></a>如何做技术选型？Sentinel 还是 Hystrix？</h3><p>Sentinel 是阿里中间件团队研发的面向分布式服务架构的轻量级高可用流量控制组件，于 2018 年 7 月正式开源。Sentinel 主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户提升服务的稳定性。大家可能会问：Sentinel 和之前经常用到的熔断降级库 Netflix Hystrix 有什么异同呢？本文将从资源模型和执行模型、隔离设计、熔断降级、实时指标统计设计等角度将 Sentinel 和 Hystrix 进行对比，希望在面临技术选型的时候，对各位开发者能有所帮助。</p>
<p>Sentinel 项目地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">https://github.com/alibaba/Sentinel</a></p>
<h4 id="总体说明"><a href="#总体说明" class="headerlink" title="总体说明"></a>总体说明</h4><p>先来看一下 Hystrix 的官方介绍：</p>
<blockquote>
<p>Hystrix is a library that helps you control the interactions between these distributed services by adding latency tolerance and fault tolerance logic. Hystrix does this by isolating points of access between the services, stopping cascading failures across them, and providing fallback options, all of which improve your system’s overall resiliency.</p>
</blockquote>
<p>可以看到 Hystrix 的关注点在于以隔离和熔断为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供 fallback 机制。</p>
<p>而 Sentinel 的侧重点在于：</p>
<ul>
<li>多样化的流量控制</li>
<li>熔断降级</li>
<li>系统负载保护</li>
<li>实时监控和控制台</li>
</ul>
<p>两者解决的问题还是有比较大的不同的，下面我们来具体对比一下。</p>
<h4 id="共同特性"><a href="#共同特性" class="headerlink" title="共同特性"></a>共同特性</h4><h5 id="1-资源模型和执行模型上的对比"><a href="#1-资源模型和执行模型上的对比" class="headerlink" title="1. 资源模型和执行模型上的对比"></a>1. 资源模型和执行模型上的对比</h5><p>Hystrix 的资源模型设计上采用了命令模式，将对外部资源的调用和 fallback 逻辑封装成一个命令对象 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code>，其底层的执行是基于 RxJava 实现的。每个 Command 创建时都要指定 <code>commandKey</code> 和 <code>groupKey</code>（用于区分资源）以及对应的隔离策略（线程池隔离 or 信号量隔离）。线程池隔离模式下需要配置线程池对应的参数（线程池名称、容量、排队超时等），然后 Command 就会在指定的线程池按照指定的容错策略执行；信号量隔离模式下需要配置最大并发数，执行 Command 时 Hystrix 就会限制其并发调用。</p>
<p><strong>注</strong>：关于 Hystrix 的详细介绍及代码演示，可以参考本项目<a target="_blank" rel="noopener" href="https://doocs.gitee.io/advanced-java/#/docs/high-availability/README">高可用架构</a>-Hystrix 部分的详细说明。</p>
<p>Sentinel 的设计则更为简单。相比 Hystrix Command 强依赖隔离规则，Sentinel 的资源定义与规则配置的耦合度更低。Hystrix 的 Command 强依赖于隔离规则配置的原因是隔离规则会直接影响 Command 的执行。在执行的时候 Hystrix 会解析 Command 的隔离规则来创建 RxJava Scheduler 并在其上调度执行，若是线程池模式则 Scheduler 底层的线程池为配置的线程池，若是信号量模式则简单包装成当前线程执行的 Scheduler。</p>
<p>而 Sentinel 则不一样，开发的时候只需要考虑这个方法&#x2F;代码是否需要保护，至于用什么来保护，可以任何时候动态实时的去修改。</p>
<p>从 <code>0.1.1</code> 版本开始，Sentinel 还支持基于注解的资源定义方式，可以通过注解参数指定异常处理函数和 fallback 函数。Sentinel 提供多样化的规则配置方式。除了直接通过 <code>loadRules</code> API 将规则注册到内存态之外，用户还可以注册各种外部数据源来提供动态的规则。用户可以根据系统当前的实时情况去动态地变更规则配置，数据源会将变更推送至 Sentinel 并即时生效。</p>
<h4 id="2-隔离设计上的对比"><a href="#2-隔离设计上的对比" class="headerlink" title="2. 隔离设计上的对比"></a>2. 隔离设计上的对比</h4><p>隔离是 Hystrix 的核心功能之一。Hystrix 提供两种隔离策略：线程池隔离 <code>Bulkhead Pattern</code> 和信号量隔离，其中最推荐也是最常用的是<strong>线程池隔离</strong>。Hystrix 的线程池隔离针对不同的资源分别创建不同的线程池，不同服务调用都发生在不同的线程池中，在线程池排队、超时等阻塞情况时可以快速失败，并可以提供 fallback 机制。线程池隔离的好处是隔离度比较高，可以针对某个资源的线程池去进行处理而不影响其它资源，但是代价就是线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。</p>
<p>但是，实际情况下，线程池隔离并没有带来非常多的好处。最直接的影响，就是会让机器资源碎片化。考虑这样一个常见的场景，在 Tomcat 之类的 Servlet 容器使用 Hystrix，本身 Tomcat 自身的线程数目就非常多了（可能到几十或一百多），如果加上 Hystrix 为各个资源创建的线程池，总共线程数目会非常多（几百个线程），这样上下文切换会有非常大的损耗。另外，线程池模式比较彻底的隔离性使得 Hystrix 可以针对不同资源线程池的排队、超时情况分别进行处理，但这其实是超时熔断和流量控制要解决的问题，如果组件具备了超时熔断和流量控制的能力，线程池隔离就显得没有那么必要了。</p>
<p>Hystrix 的信号量隔离限制对某个资源调用的并发数。这样的隔离非常轻量级，仅限制对某个资源调用的并发数，而不是显式地去创建线程池，所以 overhead 比较小，但是效果不错。但缺点是无法对慢调用自动进行降级，只能等待客户端自己超时，因此仍然可能会出现级联阻塞的情况。</p>
<p>Sentinel 可以通过并发线程数模式的流量控制来提供信号量隔离的功能。并且结合基于响应时间的熔断降级模式，可以在不稳定资源的平均响应时间比较高的时候自动降级，防止过多的慢调用占满并发数，影响整个系统。</p>
<h4 id="3-熔断降级的对比"><a href="#3-熔断降级的对比" class="headerlink" title="3. 熔断降级的对比"></a>3. 熔断降级的对比</h4><p>Sentinel 和 Hystrix 的熔断降级功能本质上都是基于熔断器模式 <code>Circuit Breaker Pattern</code>。Sentinel 与 Hystrix 都支持基于失败比率（异常比率）的熔断降级，在调用达到一定量级并且失败比率达到设定的阈值时自动进行熔断，此时所有对该资源的调用都会被 block，直到过了指定的时间窗口后才启发性地恢复。上面提到过，Sentinel 还支持基于平均响应时间的熔断降级，可以在服务响应时间持续飙高的时候自动熔断，拒绝掉更多的请求，直到一段时间后才恢复。这样可以防止调用非常慢造成级联阻塞的情况。</p>
<h4 id="4-实时指标统计实现的对比"><a href="#4-实时指标统计实现的对比" class="headerlink" title="4. 实时指标统计实现的对比"></a>4. 实时指标统计实现的对比</h4><p>Hystrix 和 Sentinel 的实时指标数据统计实现都是基于滑动窗口的。Hystrix 1.5 之前的版本是通过环形数组实现的滑动窗口，通过锁配合 CAS 的操作对每个桶的统计信息进行更新。Hystrix 1.5 开始对实时指标统计的实现进行了重构，将指标统计数据结构抽象成了响应式流（reactive stream）的形式，方便消费者去利用指标信息。同时底层改造成了基于 RxJava 的事件驱动模式，在服务调用成功&#x2F;失败&#x2F;超时的时候发布相应的事件，通过一系列的变换和聚合最终得到实时的指标统计数据流，可以被熔断器或 Dashboard 消费。</p>
<p>Sentinel 目前抽象出了 Metric 指标统计接口，底层可以有不同的实现，目前默认的实现是基于 LeapArray 的滑动窗口，后续根据需要可能会引入 reactive stream 等实现。</p>
<h3 id="Sentinel-特性"><a href="#Sentinel-特性" class="headerlink" title="Sentinel 特性"></a>Sentinel 特性</h3><p>除了之前提到的两者的共同特性之外，Sentinel 还提供以下的特色功能：</p>
<h4 id="1-轻量级、高性能"><a href="#1-轻量级、高性能" class="headerlink" title="1. 轻量级、高性能"></a>1. 轻量级、高性能</h4><p>Sentinel 作为一个功能完备的高可用流量管控组件，其核心 sentinel-core 没有任何多余依赖，打包后只有不到 200KB，非常轻量级。开发者可以放心地引入 sentinel-core 而不需担心依赖问题。同时，Sentinel 提供了多种扩展点，用户可以很方便地根据需求去进行扩展，并且无缝地切合到 Sentinel 中。</p>
<p>引入 Sentinel 带来的性能损耗非常小。只有在业务单机量级超过 25W QPS 的时候才会有一些显著的影响（5% - 10% 左右），单机 QPS 不太大的时候损耗几乎可以忽略不计。</p>
<h4 id="2-流量控制"><a href="#2-流量控制" class="headerlink" title="2. 流量控制"></a>2. 流量控制</h4><p>Sentinel 可以针对不同的调用关系，以不同的运行指标（如 QPS、并发调用数、系统负载等）为基准，对资源调用进行流量控制，将随机的请求调整成合适的形状。</p>
<p>Sentinel 支持多样化的流量整形策略，在 QPS 过高的时候可以自动将流量调整成合适的形状。常用的有：</p>
<ul>
<li><p><strong>直接拒绝模式</strong>：即超出的请求直接拒绝。</p>
</li>
<li><p><strong>慢启动预热模式</strong>：当流量激增的时候，控制流量通过的速率，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。<img src="https://tgph.319226.xyz/file/1ed7163af0bd548306eae.jpg"></p>
</li>
<li><p><strong>匀速器模式</strong>：利用 Leaky Bucket 算法实现的匀速模式，严格控制了请求通过的时间间隔，同时堆积的请求将会排队，超过超时时长的请求直接被拒绝。Sentinel 还支持基于调用关系的限流，包括基于调用方限流、基于调用链入口限流、关联流量限流等，依托于 Sentinel 强大的调用链路统计信息，可以提供精准的不同维度的限流。 <img src="https://tgph.319226.xyz/file/94f120b693a954e21e508.jpg" alt="Homogenizer-mode"></p>
</li>
</ul>
<p>目前 Sentinel 对异步调用链路的支持还不是很好，后续版本会着重改善支持异步调用。</p>
<h4 id="3-系统负载保护"><a href="#3-系统负载保护" class="headerlink" title="3. 系统负载保护"></a>3. 系统负载保护</h4><p>Sentinel 对系统的维度提供保护，负载保护算法借鉴了 TCP BBR 的思想。当系统负载较高的时候，如果仍持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>
<p><img src="https://tgph.319226.xyz/file/982a3d74399196f29b9af.jpg" alt="BRP"></p>
<h4 id="4-实时监控和控制面板"><a href="#4-实时监控和控制面板" class="headerlink" title="4. 实时监控和控制面板"></a>4. 实时监控和控制面板</h4><p>Sentinel 提供 HTTP API 用于获取实时的监控信息，如调用链路统计信息、簇点信息、规则信息等。如果用户正在使用 Spring Boot&#x2F;Spring Cloud 并使用了 Sentinel Spring Cloud Starter，还可以方便地通过其暴露的 Actuator Endpoint 来获取运行时的一些信息，如动态规则等。未来 Sentinel 还会支持标准化的指标监控 API，可以方便地整合各种监控系统和可视化系统，如 Prometheus、Grafana 等。</p>
<p>Sentinel 控制台（Dashboard）提供了机器发现、配置规则、查看实时监控、查看调用链路信息等功能，使得用户可以非常方便地去查看监控和进行配置。</p>
<p><img src="https://tgph.319226.xyz/file/53621e7956b9e7753b1c2.jpg" alt="Sentinel-Dashboard"></p>
<h4 id="5-生态"><a href="#5-生态" class="headerlink" title="5. 生态"></a>5. 生态</h4><p>Sentinel 目前已经针对 Servlet、Dubbo、Spring Boot&#x2F;Spring Cloud、gRPC 等进行了适配，用户只需引入相应依赖并进行简单配置即可非常方便地享受 Sentinel 的高可用流量防护能力。未来 Sentinel 还会对更多常用框架进行适配，并且会为 Service Mesh 提供集群流量防护的能力。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>#</th>
<th>Sentinel</th>
<th>Hystrix</th>
</tr>
</thead>
<tbody><tr>
<td>隔离策略</td>
<td>信号量隔离</td>
<td>线程池隔离&#x2F;信号量隔离</td>
</tr>
<tr>
<td>熔断降级策略</td>
<td>基于响应时间或失败比率</td>
<td>基于失败比率</td>
</tr>
<tr>
<td>实时指标实现</td>
<td>滑动窗口</td>
<td>滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td>规则配置</td>
<td>支持多种数据源</td>
<td>支持多种数据源</td>
</tr>
<tr>
<td>扩展性</td>
<td>多个扩展点</td>
<td>插件的形式</td>
</tr>
<tr>
<td>基于注解的支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持基于调用关系的限流</td>
<td>不支持</td>
</tr>
<tr>
<td>流量整形</td>
<td>支持慢启动、匀速器模式</td>
<td>不支持</td>
</tr>
<tr>
<td>系统负载保护</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>常见框架的适配</td>
<td>Servlet、Spring Cloud、Dubbo、gRPC</td>
<td>Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
<h2 id="Spring-Cloud-微服务架构"><a href="#Spring-Cloud-微服务架构" class="headerlink" title="Spring Cloud 微服务架构"></a>Spring Cloud 微服务架构</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><ul>
<li>微服务架构是一个分布式系统，按照业务进行划分成为不同的服务单元，解决单体系统性能等不足。</li>
<li>微服务是一种架构风格，一个大型软件应用由多个服务单元组成。系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。</li>
</ul>
<blockquote>
<p>微服务概念起源：<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">Microservices</a></p>
</blockquote>
<h3 id="微服务之间是如何独立通讯的"><a href="#微服务之间是如何独立通讯的" class="headerlink" title="微服务之间是如何独立通讯的"></a>微服务之间是如何独立通讯的</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h5 id="REST-HTTP-协议"><a href="#REST-HTTP-协议" class="headerlink" title="REST HTTP 协议"></a>REST HTTP 协议</h5><p>REST 请求在微服务中是最为常用的一种通讯方式，它依赖于 HTTP\HTTPS 协议。RESTFUL 的特点是：</p>
<ol>
<li>每一个 URI 代表 1 种资源</li>
<li>客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源</li>
<li>通过操作资源的表现形式来操作资源</li>
<li>资源的表现形式是 XML 或者 HTML</li>
<li>客户端与服务端之间的交互在请求之间是无状态的,从客户端到服务端的每个请求都必须包含理解请求所必需的信息</li>
</ol>
<p>举个例子，有一个服务方提供了如下接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/communication&quot;)</span><br><span class="line">public class RestControllerDemo &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String s() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个服务需要去调用该接口，调用方只需要根据 API 文档发送请求即可获取返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/demo&quot;)</span><br><span class="line">public class RestDemo&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello2&quot;)</span><br><span class="line">    public String s2() &#123;</span><br><span class="line">        String forObject = restTemplate.getForObject(&quot;http://localhost:9013/communication/hello&quot;, String.class);</span><br><span class="line">        return forObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这样的方式可以实现服务之间的通讯。</p>
<h5 id="RPC-TCP-协议"><a href="#RPC-TCP-协议" class="headerlink" title="RPC TCP 协议"></a>RPC TCP 协议</h5><p>RPC(Remote Procedure Call)远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。它的工作流程是这样的：</p>
<ol>
<li>执行客户端调用语句，传送参数</li>
<li>调用本地系统发送网络消息</li>
<li>消息传送到远程主机</li>
<li>服务器得到消息并取得参数</li>
<li>根据调用请求以及参数执行远程过程（服务）</li>
<li>执行过程完毕，将结果返回服务器句柄</li>
<li>服务器句柄返回结果，调用远程主机的系统网络服务发送结果</li>
<li>消息传回本地主机</li>
<li>客户端句柄由本地主机的网络服务接收消息</li>
<li>客户端接收到调用语句返回的结果数据</li>
</ol>
<p>举个例子。</p>
<p>首先需要一个服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RPC 服务端用来注册远程方法的接口和实现类</span><br><span class="line"> */</span><br><span class="line">public class RPCServer &#123;</span><br><span class="line">    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    private static final ConcurrentHashMap&lt;String, Class&gt; serviceRegister = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册方法</span><br><span class="line">     * @param service</span><br><span class="line">     * @param impl</span><br><span class="line">     */</span><br><span class="line">    public void register(Class service, Class impl) &#123;</span><br><span class="line">        serviceRegister.put(service.getSimpleName(), impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 启动方法</span><br><span class="line">     * @param port</span><br><span class="line">     */</span><br><span class="line">    public void start(int port) &#123;</span><br><span class="line">        ServerSocket socket = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new ServerSocket();</span><br><span class="line">            socket.bind(new InetSocketAddress(port));</span><br><span class="line">            System.out.println(&quot;服务启动&quot;);</span><br><span class="line">            System.out.println(serviceRegister);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                executor.execute(new Task(socket.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (socket != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Task implements Runnable &#123;</span><br><span class="line">        Socket client = null;</span><br><span class="line"></span><br><span class="line">        public Task(Socket client) &#123;</span><br><span class="line">            this.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            ObjectInputStream input = null;</span><br><span class="line">            ObjectOutputStream output = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                input = new ObjectInputStream(client.getInputStream());</span><br><span class="line">                // 按照顺序读取对方写过来的内容</span><br><span class="line">                String serviceName = input.readUTF();</span><br><span class="line">                String methodName = input.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">                Object[] arguments = (Object[]) input.readObject();</span><br><span class="line">                Class serviceClass = serviceRegister.get(serviceName);</span><br><span class="line">                if (serviceClass == null) &#123;</span><br><span class="line">                    throw new ClassNotFoundException(serviceName + &quot; 没有找到!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line">                Object result = method.invoke(serviceClass.newInstance(), arguments);</span><br><span class="line"></span><br><span class="line">                output = new ObjectOutputStream(client.getOutputStream());</span><br><span class="line">                output.writeObject(result);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 这里就不写 output!=null才关闭这个逻辑了</span><br><span class="line">                    output.close();</span><br><span class="line">                    input.close();</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次需要一个客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RPC 客户端</span><br><span class="line"> */</span><br><span class="line">public class RPCclient&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 通过动态代理将参数发送过去到 RPCServer ,RPCserver 返回结果这个方法处理成为正确的实体</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; T getRemoteProxyObj(final Class&lt;T&gt; service, final InetSocketAddress addr) &#123;</span><br><span class="line"></span><br><span class="line">        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]&#123;service&#125;, new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">                Socket socket = null;</span><br><span class="line">                ObjectOutputStream out = null;</span><br><span class="line">                ObjectInputStream input = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket = new Socket();</span><br><span class="line">                    socket.connect(addr);</span><br><span class="line"></span><br><span class="line">                    // 将实体类,参数,发送给远程调用方</span><br><span class="line">                    out = new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                    out.writeUTF(service.getSimpleName());</span><br><span class="line">                    out.writeUTF(method.getName());</span><br><span class="line">                    out.writeObject(method.getParameterTypes());</span><br><span class="line">                    out.writeObject(args);</span><br><span class="line"></span><br><span class="line">                    input = new ObjectInputStream(socket.getInputStream());</span><br><span class="line">                    return input.readObject();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                    input.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一个测试的远程方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Tinterface &#123;</span><br><span class="line">    String send(String msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TinterfaceImpl implements Tinterface &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String send(String msg) &#123;</span><br><span class="line">        return &quot;send message &quot; + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class RunTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                RPCServer rpcServer = new RPCServer();</span><br><span class="line">                rpcServer.register(Tinterface.class, TinterfaceImpl.class);</span><br><span class="line">                rpcServer.start(10000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Tinterface tinterface = RPCclient.getRemoteProxyObj(Tinterface.class, new InetSocketAddress(&quot;localhost&quot;, 10000));</span><br><span class="line">        System.out.println(tinterface.send(&quot;rpc 测试用例&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 <code>send message rpc 测试用例</code> 。</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h5 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h5><p>常见的消息中间件有 Kafka、ActiveMQ、RabbitMQ、RocketMQ ，常见的协议有 AMQP、MQTTP、STOMP、XMPP。</p>
<h3 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h3><h4 id="微服务开发"><a href="#微服务开发" class="headerlink" title="微服务开发"></a>微服务开发</h4><p>作用：快速开发服务。</p>
<ul>
<li>Spring</li>
<li>Spring MVC</li>
<li>Spring Boot</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spring.io/">Spring</a> 目前是 JavaWeb 开发人员必不可少的一个框架，SpringBoot 简化了 Spring 开发的配置目前也是业内主流开发框架。</p>
<h4 id="微服务注册发现"><a href="#微服务注册发现" class="headerlink" title="微服务注册发现"></a>微服务注册发现</h4><p>作用：发现服务，注册服务，集中管理服务。</p>
<h5 id="Eureka-1"><a href="#Eureka-1" class="headerlink" title="Eureka"></a>Eureka</h5><ul>
<li>Eureka Server : 提供服务注册服务, 各个节点启动后，会在 Eureka Server 中进行注册。</li>
<li>Eureka Client : 简化与 Eureka Server 的交互操作。</li>
<li>Spring Cloud Netflix : <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-netflix">GitHub</a>，<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-netflix/reference/html/">文档</a></li>
</ul>
<h5 id="Zookeeper-1"><a href="#Zookeeper-1" class="headerlink" title="Zookeeper"></a>Zookeeper</h5><blockquote>
<p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper">Zookeeper</a> 是一个集中的服务, 用于维护配置信息、命名、提供分布式同步和提供组服务。</p>
<h5 id="Zookeeper-和-Eureka-区别"><a href="#Zookeeper-和-Eureka-区别" class="headerlink" title="Zookeeper 和 Eureka 区别"></a>Zookeeper 和 Eureka 区别</h5><p>Zookeeper 保证 CP，Eureka 保证 AP：</p>
<ul>
<li>C：数据一致性；</li>
<li>A：服务可用性；</li>
<li>P：服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。</li>
</ul>
<h4 id="微服务配置管理"><a href="#微服务配置管理" class="headerlink" title="微服务配置管理"></a>微服务配置管理</h4><p>作用：统一管理一个或多个服务的配置信息, 集中管理。</p>
<h5 id="Disconf"><a href="#Disconf" class="headerlink" title="Disconf"></a><a target="_blank" rel="noopener" href="https://github.com/knightliao/disconf">Disconf</a></h5><p>Distributed Configuration Management Platform(分布式配置管理平台) , 它是专注于各种分布式系统配置管理 的通用组件&#x2F;通用平台, 提供统一的配置管理服务, 是一套完整的基于 zookeeper 的分布式配置统一解决方案。</p>
<h5 id="SpringCloudConfig"><a href="#SpringCloudConfig" class="headerlink" title="SpringCloudConfig"></a><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-config">SpringCloudConfig</a></h5><h5 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a><a target="_blank" rel="noopener" href="https://github.com/ctripcorp/apollo">Apollo</a></h5><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，用于微服务配置管理场景。</p>
<h4 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h4><p>作用：根据系统设置的安全规则或者安全策略, 用户可以访问而且只能访问自己被授权的资源，不多不少。</p>
<h5 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-security">Spring Security</a></h5><h5 id="Apache-Shiro"><a href="#Apache-Shiro" class="headerlink" title="Apache Shiro"></a><a target="_blank" rel="noopener" href="http://shiro.apache.org/">Apache Shiro</a></h5><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>作用: 批量处理同类型数据或事物</p>
<h5 id="Spring-Batch"><a href="#Spring-Batch" class="headerlink" title="Spring Batch"></a><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-batch">Spring Batch</a></h5><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><blockquote>
<p>作用: 定时做什么。</p>
</blockquote>
<h5 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a><a target="_blank" rel="noopener" href="http://www.quartz-scheduler.org/">Quartz</a></h5><h4 id="微服务调用-协议"><a href="#微服务调用-协议" class="headerlink" title="微服务调用 (协议)"></a>微服务调用 (协议)</h4><blockquote>
<p>通讯协议</p>
</blockquote>
<h5 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h5><ul>
<li>通过 HTTP&#x2F;HTTPS 发送 Rest 请求进行数据交互</li>
</ul>
<h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><ul>
<li>Remote Procedure Call</li>
<li>它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC 不依赖于具体的网络传输协议，tcp、udp 等都可以。</li>
</ul>
<h5 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a><a target="_blank" rel="noopener" href="https://www.grpc.io/">gRPC</a></h5><blockquote>
<p>A high-performance, open-source universal RPC framework</p>
</blockquote>
<p>所谓 RPC(remote procedure call 远程过程调用) 框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从 server&#x2F;client 模型。使用的时候客户端调用 server 端提供的接口就像是调用本地的函数一样。</p>
<h5 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h5><ul>
<li>Remote Method Invocation</li>
<li>纯 Java 调用</li>
</ul>
<h4 id="服务接口调用"><a href="#服务接口调用" class="headerlink" title="服务接口调用"></a>服务接口调用</h4><blockquote>
<p>作用：多个服务之间的通讯</p>
</blockquote>
<h5 id="Feign-HTTP"><a href="#Feign-HTTP" class="headerlink" title="Feign(HTTP)"></a><a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">Feign(HTTP)</a></h5><p>Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去调用，而 Feign 是一个使用起来更加方便的 HTTP 客戶端，使用起来就像是调用自身工程的方法，而感觉不到是调用远程方法。</p>
<h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><blockquote>
<p>作用: 当请求到达一定阈值时不让请求继续.</p>
</blockquote>
<h5 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix</a></h5><blockquote>
<p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p>
</blockquote>
<h5 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a></h5><blockquote>
<p>A lightweight powerful flow control component enabling reliability and monitoring for microservices. (轻量级的流量控制、熔断降级 Java 库)</p>
</blockquote>
<h4 id="服务的负载均衡"><a href="#服务的负载均衡" class="headerlink" title="服务的负载均衡"></a>服务的负载均衡</h4><blockquote>
<p>作用：降低服务压力, 增加吞吐量</p>
</blockquote>
<h5 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a><a target="_blank" rel="noopener" href="https://github.com/Netflix/ribbon">Ribbon</a></h5><blockquote>
<p>Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具, 它基于 Netflix Ribbon 实现</p>
</blockquote>
<h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a><a target="_blank" rel="noopener" href="https://github.com/nginx/nginx">Nginx</a></h5><p>Nginx (engine x) 是一个高性能的 HTTP 和反向代理 web 服务器, 同时也提供了 IMAP&#x2F;POP3&#x2F;SMTP 服务</p>
<h5 id="Nginx-与-Ribbon-区别"><a href="#Nginx-与-Ribbon-区别" class="headerlink" title="Nginx 与 Ribbon 区别"></a>Nginx 与 Ribbon 区别</h5><p>Nginx 属于服务端负载均衡，Ribbon 属于客户端负载均衡。Nginx 作用与 Tomcat，Ribbon 作用与各个服务之间的调用 (RPC)。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><blockquote>
<p>作用: 解耦业务, 异步化处理数据</p>
</blockquote>
<h5 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka</a></h5><h5 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a></h5><h5 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a><a target="_blank" rel="noopener" href="http://rocketmq.apache.org/">RocketMQ</a></h5><h5 id="activeMQ"><a href="#activeMQ" class="headerlink" title="activeMQ"></a><a target="_blank" rel="noopener" href="http://activemq.apache.org/">activeMQ</a></h5><h4 id="日志采集-elk"><a href="#日志采集-elk" class="headerlink" title="日志采集 (elk)"></a>日志采集 (elk)</h4><blockquote>
<p>作用: 收集各服务日志提供日志分析、用户画像等</p>
</blockquote>
<h5 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a></h5><h5 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash</a></h5><h5 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a><a target="_blank" rel="noopener" href="https://github.com/elastic/kibana">Kibana</a></h5><h4 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h4><blockquote>
<p>作用: 外部请求通过 API 网关进行拦截处理, 再转发到真正的服务</p>
</blockquote>
<h5 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a><a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul">Zuul</a></h5><blockquote>
<p>Zuul is a gateway service that provides dynamic routing, monitoring, resiliency, security, and more.</p>
</blockquote>
<h4 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h4><p>作用: 以可视化或非可视化的形式展示出各个服务的运行情况 (CPU、内存、访问量等)</p>
<h5 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a><a target="_blank" rel="noopener" href="https://github.com/jjmartres/Zabbix">Zabbix</a></h5><h5 id="Nagios"><a href="#Nagios" class="headerlink" title="Nagios"></a><a target="_blank" rel="noopener" href="https://www.nagios.org/">Nagios</a></h5><h5 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a><a target="_blank" rel="noopener" href="https://metrics.dropwizard.io/">Metrics</a></h5><h5 id="服务链路追踪"><a href="#服务链路追踪" class="headerlink" title="服务链路追踪"></a>服务链路追踪</h5><blockquote>
<p>作用: 明确服务之间的调用关系</p>
</blockquote>
<h5 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a><a target="_blank" rel="noopener" href="https://github.com/openzipkin/zipkin">Zipkin</a></h5><h5 id="Brave"><a href="#Brave" class="headerlink" title="Brave"></a><a target="_blank" rel="noopener" href="https://github.com/openzipkin/brave">Brave</a></h5><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><blockquote>
<p>作用: 存储数据</p>
</blockquote>
<h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><h6 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a><a target="_blank" rel="noopener" href="https://www.mysql.com/">MySql</a></h6><h6 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a><a target="_blank" rel="noopener" href="https://www.oracle.com/index.html">Oracle</a></h6><h6 id="MsSQL"><a href="#MsSQL" class="headerlink" title="MsSQL"></a><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sql/?view=sql-server-ver15">MsSQL</a></h6><h6 id="PostgreSql"><a href="#PostgreSql" class="headerlink" title="PostgreSql"></a><a target="_blank" rel="noopener" href="https://www.postgresql.org/">PostgreSql</a></h6><h5 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h5><h5 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a><a target="_blank" rel="noopener" href="https://www.mongodb.com/">Mongodb</a></h5><h5 id="Elasticsearch-1"><a href="#Elasticsearch-1" class="headerlink" title="Elasticsearch"></a><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch">Elasticsearch</a></h5><h4 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h4><blockquote>
<p>作用: 存储数据</p>
</blockquote>
<h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a><a target="_blank" rel="noopener" href="https://redis.io/">redis</a></h5><h4 id="分库分表-1"><a href="#分库分表-1" class="headerlink" title="分库分表"></a>分库分表</h4><blockquote>
<p>作用: 数据库分库分表方案.</p>
</blockquote>
<h5 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a><a target="_blank" rel="noopener" href="http://shardingsphere.apache.org/">ShardingSphere</a></h5><h5 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a><a target="_blank" rel="noopener" href="http://www.mycat.io/">Mycat</a></h5><h4 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h4><blockquote>
<p>作用: 将项目快速部署、上线、持续集成.</p>
</blockquote>
<h5 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><a target="_blank" rel="noopener" href="http://www.docker.com/">Docker</a></h5><h5 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><a target="_blank" rel="noopener" href="https://jenkins.io/zh/">Jenkins</a></h5><h5 id="Kubernetes-K8s"><a href="#Kubernetes-K8s" class="headerlink" title="Kubernetes(K8s)"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes(K8s)</a></h5><h5 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a><a target="_blank" rel="noopener" href="http://mesos.apache.org/">Mesos</a></h5><h3 id="微服务治理策略"><a href="#微服务治理策略" class="headerlink" title="微服务治理策略"></a>微服务治理策略</h3><h4 id="服务的注册和发现"><a href="#服务的注册和发现" class="headerlink" title="服务的注册和发现"></a>服务的注册和发现</h4><p>解决问题：集中管理服务  </p>
<p>解决方法：  </p>
<ul>
<li>Eureka  </li>
<li>Zookeeper</li>
</ul>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>解决问题：降低服务器硬件压力  </p>
<p>解决方法：  </p>
<ul>
<li>Nginx  </li>
<li>Ribbon</li>
</ul>
<h4 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h4><p>解决问题：各个服务之间的沟通桥梁  </p>
<p>解决方法：  </p>
<ul>
<li>REST（同步）  </li>
<li>RPC（同步）  </li>
<li>MQ（异步）</li>
</ul>
<h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>解决问题：随着服务的增加配置也在增加，如何管理各个服务的配置。  </p>
<p>解决方法：  </p>
<ul>
<li>Nacos  </li>
<li>Spring Cloud Config  </li>
<li>Apollo</li>
</ul>
<h4 id="容错和服务降级"><a href="#容错和服务降级" class="headerlink" title="容错和服务降级"></a>容错和服务降级</h4><p>解决问题：在微服务当中，一个请求经常会涉及到调用几个服务，如果其中某个服务不可以，没有做服务容错的话，极有可能会造成一连串的服务不可用，这就是雪崩效应。  </p>
<p>解决方法：  </p>
<ul>
<li>Hystrix</li>
</ul>
<h4 id="服务依赖关系"><a href="#服务依赖关系" class="headerlink" title="服务依赖关系"></a>服务依赖关系</h4><p>解决问题：多个服务之间来回依赖，启动关系的不明确。  </p>
<p>解决方法：应用分层。  </p>
<h4 id="服务文档"><a href="#服务文档" class="headerlink" title="服务文档"></a>服务文档</h4><p>解决问题：降低沟通成本  </p>
<p>解决方法：  </p>
<ul>
<li>Swagger  </li>
<li>Java doc</li>
</ul>
<h4 id="服务安全问题"><a href="#服务安全问题" class="headerlink" title="服务安全问题"></a>服务安全问题</h4><p>解决问题：敏感数据的安全性  </p>
<p>解决方法：  </p>
<ul>
<li>Oauth  </li>
<li>Shiro  </li>
<li>Spring Security</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>解决问题：避免一个服务上的流量过大拖垮整个服务体系  </p>
<p>解决方法：  </p>
<ul>
<li>Hystrix</li>
</ul>
<h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><p>解决问题：提前预知异常，确定服务是否可用  </p>
<p>解决方法：  </p>
<ul>
<li>junit</li>
</ul>
<h4 id="服务上线"><a href="#服务上线" class="headerlink" title="服务上线"></a>服务上线</h4><p>解决问题：避免服务随意的上线下线  </p>
<p>解决方法：新服务上线需要经过管理人员审核，服务下线需要告知各个调用方进行修改，直到没有调用该服务才可以进行下线。  </p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>解决问题：服务开发持续进行如何做到兼容。  </p>
<p>解决方法：通过版本号的形式进行管理，修改完成进行回归测试。  </p>
<h4 id="服务编排"><a href="#服务编排" class="headerlink" title="服务编排"></a>服务编排</h4><p>解决问题：解决服务依赖问题的一种方式  </p>
<p>解决方法：  </p>
<ul>
<li>Docker  </li>
<li>K8s</li>
</ul>
<h4 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h4><p>解决问题：每个服务的资源占用量不同，如何分配  </p>
<p>解决方法：  </p>
<ul>
<li>JVM 隔离  </li>
<li>Classload 隔离  </li>
<li>硬件隔离</li>
</ul>
<h4 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h4><p>解决问题：随着时间增长，调用逐步增加，什么时候追加机器。  </p>
<p>解决方法：统计每日调用量和响应时间，根据机器情况设置阈值，超过阈值就可以追加机器。</p>
<h3 id="服务发现组件-Eureka-的几个主要调用过程"><a href="#服务发现组件-Eureka-的几个主要调用过程" class="headerlink" title="服务发现组件 Eureka 的几个主要调用过程"></a>服务发现组件 Eureka 的几个主要调用过程</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为 <code>微服务</code> ），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。 一个比较好的解决方案就是 <code>服务发现（Service Discovery）</code> 。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 <code>apache</code> 的 <a target="_blank" rel="noopener" href="https://github.com/apache/zookeeper">zookeeper</a>、 <code>Netflix</code> 的 <a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka">eureka</a>、 <code>hashicorp</code> 的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/consul">consul</a>、 <code>CoreOS</code> 的 <a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd">etcd</a>。  </p>
<h4 id="Eureka-是什么"><a href="#Eureka-是什么" class="headerlink" title="Eureka 是什么"></a>Eureka 是什么</h4><p><code>Eureka</code> 在 <a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka">GitHub</a> 上对其的定义为  </p>
<blockquote>
<p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.  </p>
</blockquote>
<p>At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.  </p>
<p><code>Eureka</code> 是由 <a target="_blank" rel="noopener" href="https://www.netflix.com/">Netflix</a> 公司开源，采用的是 Client &#x2F; Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 <code>Spring Cloud</code> 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 <a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wik">github wiki</a> 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。  </p>
<h4 id="服务注册中心（Eureka-Server）"><a href="#服务注册中心（Eureka-Server）" class="headerlink" title="服务注册中心（Eureka Server）"></a>服务注册中心（Eureka Server）</h4><p>我们在项目中引入 <code>Eureka Server</code> 的相关依赖，然后在启动类加上注解 <code>@EnableEurekaServer</code> ，就可以将其作为注册中心，启动服务后访问页面如下：  </p>
<p><img src="https://tgph.319226.xyz/file/fa19777bdb622547bdde3.png" alt="eureka-server-homepage.png">  </p>
<p>我们继续添加两个模块 <code>service-provider</code> ， <code>service-consumer</code> ，然后在启动类加上注解 <code>@EnableEurekaClient</code> 并指定注册中心地址为我们刚刚启动的 <code>Eureka Server</code> ，再次访问可以看到两个服务都已经注册进来了。  </p>
<p><img src="https://tgph.319226.xyz/file/c1277bcff72bbe574a2ad.png" alt="eureka-instance-registered-currently.png">  </p>
<p>可以看到 <code>Eureka</code> 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。  </p>
<h5 id="服务注册（Register）"><a href="#服务注册（Register）" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 <code>POST</code> 请求带上当前实例信息到类 <code>ApplicationResource</code> 的 <code>addInstance</code> 方法进行服务注册。  </p>
<p><img src="https://tgph.319226.xyz/file/855ad36cda66367223cfe.png" alt="eureka-server-applicationresource-addinstance.png">  </p>
<p>可以看到方法调用了类 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>register</code> 方法，该方法主要分为两步：  </p>
<ol>
<li>调用父类 <code>AbstractInstanceRegistry</code> 的 <code>register</code> 方法把当前服务注册到注册中心  </li>
<li>调用 <code>replicateToPeers</code> 方法使用异步的方式向其它的 <code>Eureka Server</code> 节点同步服务注册信息</li>
</ol>
<p>服务注册信息保存在一个嵌套的 <code>map</code> 中，它的结构如下：  </p>
<p><img src="https://tgph.319226.xyz/file/abc76aea1f361657b456a.png" alt="eureka-server-registry-structure.png">  </p>
<p>第一层 <code>map</code> 的 <code>key</code> 是应用名称（对应 <code>Demo</code> 里的 <code>SERVICE-PROVIDER</code> ），第二层 <code>map</code> 的 <code>key</code> 是应用对应的实例名称（对应 <code>Demo</code> 里的 <code>mghio-mbp:service-provider:9999</code> ），一个应用可以有多个实例，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/9516c9d8dd94a2a7da8b0.png" alt="eureka-server-register-sequence-chart.png">  </p>
<h5 id="服务续约（Renew）"><a href="#服务续约（Renew）" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约会由服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code> ）定期调用，类似于心跳，用来告知注册中心 <code>Eureka Server</code> 自己的状态，避免被 <code>Eureka Server</code> 认为服务时效将其剔除下线。服务续约就是发送一个 <code>PUT</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>renewLease</code> 方法进行服务续约操作。  </p>
<p><img src="https://tgph.319226.xyz/file/153b47b146456dcaf17a1.png" alt="eureka-server-instanceresource-renew.png">  </p>
<p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>renew</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 <code>Eureka Server</code> 节点的状态，服务续约成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/88d6ab36612d7854bbf24.png" alt="eureka-server-renew-sequence-chart.png">  </p>
<h5 id="服务下线（Cancel）"><a href="#服务下线（Cancel）" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code> ）停止服务时，会发送请求告知注册中心 <code>Eureka Server</code> 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 <code>DELETE</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>cancelLease</code> 方法进行服务剔除下线操作。  </p>
<p><img src="https://tgph.319226.xyz/file/165fe6c5b609456b00b38.png" alt="eureka-server-instanceresource-cancellease.png">  </p>
<p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>cancel</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 <code>Eureka Server</code> 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/41fb1cf751257ae7a886b.png" alt="eureka-server-cancellease-sequence-chart.png">  </p>
<h5 id="服务剔除（Eviction）"><a href="#服务剔除（Eviction）" class="headerlink" title="服务剔除（Eviction）"></a>服务剔除（Eviction）</h5><p>服务剔除是注册中心 <code>Eureka Server</code> 在启动时就启动一个守护线程 <code>evictionTimer</code> 来定期（默认为 <code>60</code> 秒）执行检测服务的，判断标准就是超过一定时间没有进行 <code>Renew</code> 的服务，默认的失效时间是 <code>90</code> 秒，也就是说当一个已注册的服务在 <code>90</code> 秒内没有向注册中心 <code>Eureka Server</code> 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 <code>eureka.instance.leaseExpirationDurationInSeconds</code> 进行修改，定期执行检测服务可以通过配置 <code>eureka.server.evictionIntervalTimerInMs</code> 进行修改，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/8e49a4d8c23c9446b5b69.png" alt="eureka-server-evict-sequence-chart.png">  </p>
<h4 id="服务提供者（Service-Provider）"><a href="#服务提供者（Service-Provider）" class="headerlink" title="服务提供者（Service Provider）"></a>服务提供者（Service Provider）</h4><p>对于服务提供方（比如 <code>Demo</code> 中的 <code>service-provider</code> 服务）来说，主要有三大类操作，分别为 <code>服务注册（Register）</code> 、 <code>服务续约（Renew）</code> 、 <code>服务下线（Cancel）</code> ，接下来看看这三个操作是如何实现的。  </p>
<h5 id="服务注册（Register）-1"><a href="#服务注册（Register）-1" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>一个服务要对外提供服务，首先要在注册中心 <code>Eureka Server</code> 进行服务相关信息注册，能进行这一步的前提是你要配置 <code>eureka.client.register-with-eureka=true</code> ，这个默认值为 <code>true</code> ，注册中心不需要把自己注册到注册中心去，把这个配置设为 <code>false</code> ，这个调用比较简单，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/2e78cab994acfdbe886b0.png" alt="eureka-service-provider-register-sequence-chart.png">  </p>
<h5 id="服务续约（Renew）-1"><a href="#服务续约（Renew）-1" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约是由服务提供者方定期（默认为 <code>30</code> 秒）发起心跳的，主要是用来告知注册中心 <code>Eureka Server</code> 自己状态是正常的还活着，可以通过配置 <code>eureka.instance.lease-renewal-interval-in-seconds</code> 来修改，当然服务续约的前提是要配置 <code>eureka.client.register-with-eureka=true</code> ，将该服务注册到注册中心中去，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/88c7e0a2a779c18872c0c.png" alt="eureka-service-provider-renew-sequence-chart.png">  </p>
<h5 id="服务下线（Cancel）-1"><a href="#服务下线（Cancel）-1" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者方服务停止时，要发送 <code>DELETE</code> 请求告知注册中心 <code>Eureka Server</code> 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 <code>DiscoveryClient</code> 的 <code>shutdown</code> 方法加上注解 <code>@PreDestroy</code> ，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/7a83872d1a3c53b6705d2.png" alt="eureka-service-provider-cancel-sequence-chart.png">  </p>
<h4 id="服务消费者（Service-Consumer）"><a href="#服务消费者（Service-Consumer）" class="headerlink" title="服务消费者（Service Consumer）"></a>服务消费者（Service Consumer）</h4><p>这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心 <code>获取服务列表（Fetch）</code> 和 <code>更新服务列表（Update）</code> 。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。  </p>
<h5 id="获取服务列表（Fetch）"><a href="#获取服务列表（Fetch）" class="headerlink" title="获取服务列表（Fetch）"></a>获取服务列表（Fetch）</h5><p>服务消费者方启动之后首先肯定是要先从注册中心 <code>Eureka Server</code> 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 <code>DiscoverClient</code> 类实例化的时候执行的。  </p>
<p><img src="https://tgph.319226.xyz/file/4ce2d75c396e917d1a3bb.png" alt="eureka-service-consumer-fetchregistry.png">  </p>
<p>可以看出，能发生这个获取服务列表的操作前提是要保证配置了 <code>eureka.client.fetch-registry=true</code> ，该配置的默认值为 <code>true</code> ，主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/4de910e7740e148de1ba6.png" alt="eureka-service-consumer-fetch-sequence-chart.png">  </p>
<h5 id="更新服务列表（Update）"><a href="#更新服务列表（Update）" class="headerlink" title="更新服务列表（Update）"></a>更新服务列表（Update）</h5><p>由上面的 <code>获取服务列表（Fetch）</code> 操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 <code>Eureka Server</code> 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 <code>eureka.client.registry-fetch-interval-seconds</code> 修改，默认为 <code>30</code> 秒，能进行这一步更新服务列表的前提是你要配置 <code>eureka.client.register-with-eureka=true</code> ，这个默认值为 <code>true</code> 。主要调用流程如下图所示：  </p>
<p><img src="https://tgph.319226.xyz/file/a0358877f52c999692373.png" alt="eureka-service-consumer-update-sequence-chart.png">  </p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>工作中项目使用的是 <code>Spring Cloud</code> 技术栈，它有一套非常完善的开源代码来整合 <code>Eureka</code> ，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 <code>Eureka</code> 服务发现组件有了更近一步的了解。</p>
<h2 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h2><h3 id="如何从大量的-URL-中找出相同的-URL？"><a href="#如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="如何从大量的 URL 中找出相同的 URL？"></a>如何从大量的 URL 中找出相同的 URL？</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。  </p>
<h4 id="解答思路"><a href="#解答思路" class="headerlink" title="解答思路"></a>解答思路</h4><h5 id="1-分治策略"><a href="#1-分治策略" class="headerlink" title="1. 分治策略"></a>1. 分治策略</h5><p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。  </p>
<blockquote>
<p>5, 000, 000, 000 _ 64B ≈ 5GB _ 64 &#x3D; 320GB  </p>
</blockquote>
<p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。  </p>
<p><strong>思路如下</strong>：  </p>
<p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。  </p>
<p>接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。  </p>
<h5 id="2-前缀树"><a href="#2-前缀树" class="headerlink" title="2. 前缀树"></a>2. 前缀树</h5><p>一般而言，URL 的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>（trie tree） 这种数据结构来进行存储，降低存储成本的同时，提高查询效率。  </p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><h5 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h5><ol>
<li>分而治之，进行哈希取余；  </li>
<li>对每个子文件进行 HashSet 统计。</li>
</ol>
<h5 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h5><ol>
<li>利用字符串的公共前缀来降低存储成本，提高查询效率。</li>
</ol>
<h3 id="如何从大量数据中找出高频词？"><a href="#如何从大量数据中找出高频词？" class="headerlink" title="如何从大量数据中找出高频词？"></a>如何从大量数据中找出高频词？</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。  </p>
<h4 id="解答思路-1"><a href="#解答思路-1" class="headerlink" title="解答思路"></a>解答思路</h4><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。  </p>
<p><strong>思路如下</strong>：  </p>
<p>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。  </p>
<p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。  </p>
<p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。  </p>
<h4 id="方法总结-1"><a href="#方法总结-1" class="headerlink" title="方法总结"></a>方法总结</h4><ol>
<li>分而治之，进行哈希取余；  </li>
<li>使用 HashMap 统计频数；  </li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ol>
<h3 id="如何找出某一天访问百度网站最多的-IP？"><a href="#如何找出某一天访问百度网站最多的-IP？" class="headerlink" title="如何找出某一天访问百度网站最多的 IP？"></a>如何找出某一天访问百度网站最多的 IP？</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。  </p>
<h4 id="解答思路-2"><a href="#解答思路-2" class="headerlink" title="解答思路"></a>解答思路</h4><p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。  </p>
<blockquote>
<p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。  </p>
</blockquote>
<h4 id="方法总结-2"><a href="#方法总结-2" class="headerlink" title="方法总结"></a>方法总结</h4><ol>
<li>分而治之，进行哈希取余；  </li>
<li>使用 HashMap 统计频数；  </li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ol>
<h3 id="如何在大量的数据中找出不重复的整数？"><a href="#如何在大量的数据中找出不重复的整数？" class="headerlink" title="如何在大量的数据中找出不重复的整数？"></a>如何在大量的数据中找出不重复的整数？</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。  </p>
<h4 id="解答思路-3"><a href="#解答思路-3" class="headerlink" title="解答思路"></a>解答思路</h4><h5 id="方法一分治法"><a href="#方法一分治法" class="headerlink" title="方法一分治法"></a>方法一分治法</h5><p>与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet&#x2F;HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。  </p>
<h5 id="方法二位图法"><a href="#方法二位图法" class="headerlink" title="方法二位图法"></a>方法二位图法</h5><p><strong>位图</strong>，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。  </p>
<p>位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。  </p>
<p>假设我们要对 <code>[0,7]</code> 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：  </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">0 0 0 0 1 0 1 0  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">依次遍历，结束后，位数组是这样的：  </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">0 1 1 0 1 1 1 0  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">每个为 1 的位，它的下标都表示了一个数：  </span><br><span class="line">  </span><br><span class="line">```  </span><br><span class="line">for i in range(8):  </span><br><span class="line">    if bits[i] == 1:        print(i)```  </span><br><span class="line">  </span><br><span class="line">这样我们其实就已经实现了排序。  </span><br><span class="line">  </span><br><span class="line">对于整数相关的算法的求解，**位图法**是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。  </span><br><span class="line">  </span><br><span class="line">**那么对于这道题**，我们用 2 个 bit 来表示各个数字的状态：  </span><br><span class="line">  </span><br><span class="line">- 00 表示这个数字没出现过；  </span><br><span class="line">- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；  </span><br><span class="line">- 10 表示这个数字出现了多次。  </span><br><span class="line">  </span><br><span class="line">那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：  </span><br><span class="line">  </span><br><span class="line">遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。  </span><br><span class="line">  </span><br><span class="line">当然，本题中特别说明：**内存不足以容纳这 2.5 亿个整数**，2.5 亿个整数的内存大小为：2.5e8/1024/1024/1024 * 4=3.72GB， 如果内存大于 1GB，是可以通过位图法解决的。  </span><br><span class="line">  </span><br><span class="line">#### 方法总结  </span><br><span class="line">  </span><br><span class="line">**判断数字是否重复的问题**，位图法是一种非常高效的方法，当然前提是：内存要满足位图法所需要的存储空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何在大量的数据中判断一个数是否存在？"><a href="#如何在大量的数据中判断一个数是否存在？" class="headerlink" title="如何在大量的数据中判断一个数是否存在？"></a>如何在大量的数据中判断一个数是否存在？</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？  </p>
<h4 id="解答思路-4"><a href="#解答思路-4" class="headerlink" title="解答思路"></a>解答思路</h4><h5 id="方法一：分治法"><a href="#方法一：分治法" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h5><p>依然可以用分治法解决，方法与前面类似，就不再次赘述了。  </p>
<h5 id="方法二：位图法"><a href="#方法二：位图法" class="headerlink" title="方法二：位图法"></a>方法二：位图法</h5><p>由于 unsigned int 数字的范围是 <code>[0, 1 &lt;&lt; 32)</code>，我们用 <code>1&lt;&lt;32=4,294,967,296</code> 个 bit 来表示每个数字。初始位均为 0，那么总共需要内存：4,294,967,296b≈512M。  </p>
<p>我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。  </p>
<h4 id="方法总结-3"><a href="#方法总结-3" class="headerlink" title="方法总结"></a>方法总结</h4><p><strong>判断数字是否存在、判断数字是否重复的问题</strong>，位图法是一种非常高效的方法。</p>
<h3 id="如何查询最热门的查询串？"><a href="#如何查询最热门的查询串？" class="headerlink" title="如何查询最热门的查询串？"></a>如何查询最热门的查询串？</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。  </p>
<p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）  </p>
<h4 id="解答思路-5"><a href="#解答思路-5" class="headerlink" title="解答思路"></a>解答思路</h4><p>每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。  </p>
<h5 id="方法一：分治法-1"><a href="#方法一：分治法-1" class="headerlink" title="方法一：分治法"></a>方法一：分治法</h5><p>分治法依然是一个非常实用的方法。  </p>
<p>划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。  </p>
<p>方法可行，但不是最好，下面介绍其他方法。  </p>
<h5 id="方法二：HashMap-法"><a href="#方法二：HashMap-法" class="headerlink" title="方法二：HashMap 法"></a>方法二：HashMap 法</h5><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。  </p>
<p><strong>思路如下</strong>：  </p>
<p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。  </p>
<p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。  </p>
<p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。  </p>
<h5 id="方法三：前缀树法"><a href="#方法三：前缀树法" class="headerlink" title="方法三：前缀树法"></a>方法三：前缀树法</h5><p>方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。  </p>
<p><strong>思路如下</strong>：  </p>
<p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。  </p>
<p>最后依然使用小顶堆来对字符串的出现次数进行排序。  </p>
<h4 id="方法总结-4"><a href="#方法总结-4" class="headerlink" title="方法总结"></a>方法总结</h4><p>前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。</p>
<h3 id="如何统计不同电话号码的个数？"><a href="#如何统计不同电话号码的个数？" class="headerlink" title="如何统计不同电话号码的个数？"></a>如何统计不同电话号码的个数？</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。  </p>
<h4 id="解答思路-6"><a href="#解答思路-6" class="headerlink" title="解答思路"></a>解答思路</h4><p>这道题本质还是求解<strong>数据重复</strong>的问题，对于这类问题，一般首先考虑位图法。  </p>
<p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 12M。  </p>
<p><strong>思路如下</strong>：  </p>
<p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。  </p>
<h4 id="方法总结-5"><a href="#方法总结-5" class="headerlink" title="方法总结"></a>方法总结</h4><p>求解数据重复问题，记得考虑位图法。  </p>
<h3 id="如何从-5-亿个数中找出中位数？"><a href="#如何从-5-亿个数中找出中位数？" class="headerlink" title="如何从 5 亿个数中找出中位数？"></a>如何从 5 亿个数中找出中位数？</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。  </p>
<h4 id="解答思路-7"><a href="#解答思路-7" class="headerlink" title="解答思路"></a>解答思路</h4><p>如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 <code>O(NlogN)</code> 。这里使用其他方法。  </p>
<h5 id="方法一：双堆法"><a href="#方法一：双堆法" class="headerlink" title="方法一：双堆法"></a>方法一：双堆法</h5><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。  </p>
<p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。  </p>
<pre><code>class MedianFinder &#123;  
  
    private PriorityQueue&lt;Integer&gt; maxHeap;    private PriorityQueue&lt;Integer&gt; minHeap;  
    /** initialize your data structure here. */    public MedianFinder() &#123;        maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());        minHeap = new PriorityQueue&lt;&gt;(Integer::compareTo);    &#125;  
    public void addNum(int num) &#123;        if (maxHeap.isEmpty() || maxHeap.peek() &gt; num) &#123;            maxHeap.offer(num);        &#125; else &#123;            minHeap.offer(num);        &#125;  
        int size1 = maxHeap.size();        int size2 = minHeap.size();        if (size1 - size2 &gt; 1) &#123;            minHeap.offer(maxHeap.poll());        &#125; else if (size2 - size1 &gt; 1) &#123;            maxHeap.offer(minHeap.poll());        &#125;    &#125;  
    public double findMedian() &#123;        int size1 = maxHeap.size();        int size2 = minHeap.size();  
        return size1 == size2            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2            : (size1 &gt; size2 ? maxHeap.peek() : minHeap.peek());    &#125;&#125;  
</code></pre>
<blockquote>
<p>见 LeetCode No.295：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-median-from-data-stream/">https://leetcode.com/problems/find-median-from-data-stream/</a>  </p>
</blockquote>
<p>以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法<strong>适用于数据量较小的情况</strong>。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。  </p>
<h5 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h5><p>分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。  </p>
<p>对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。  </p>
<p>划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。  </p>
<blockquote>
<p><strong>提示</strong>，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。  </p>
</blockquote>
<p>对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。  </p>
<blockquote>
<p><strong>注意</strong>，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。  </p>
</blockquote>
<h4 id="方法总结-6"><a href="#方法总结-6" class="headerlink" title="方法总结"></a>方法总结</h4><p>分治法，真香！  </p>
<h3 id="如何按照-query-的频度排序？"><a href="#如何按照-query-的频度排序？" class="headerlink" title="如何按照 query 的频度排序？"></a>如何按照 query 的频度排序？</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。  </p>
<h4 id="解答思路-8"><a href="#解答思路-8" class="headerlink" title="解答思路"></a>解答思路</h4><p>如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。  </p>
<h5 id="方法一：HashMap-法"><a href="#方法一：HashMap-法" class="headerlink" title="方法一：HashMap 法"></a>方法一：HashMap 法</h5><p>如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。  </p>
<h5 id="方法二：分治法-1"><a href="#方法二：分治法-1" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h5><p>分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 <code>hash(query) % 10</code> 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到另外一个单独文件中。  </p>
<p>接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。  </p>
<h4 id="方法总结-7"><a href="#方法总结-7" class="headerlink" title="方法总结"></a>方法总结</h4><ul>
<li>内存若够，直接读入进行排序；  </li>
<li>内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。</li>
</ul>
<h3 id="如何找出排名前-500-的数？"><a href="#如何找出排名前-500-的数？" class="headerlink" title="如何找出排名前 500 的数？"></a>如何找出排名前 500 的数？</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？  </p>
<h4 id="解答思路-9"><a href="#解答思路-9" class="headerlink" title="解答思路"></a>解答思路</h4><p>对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：  </p>
<p>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。  </p>
<p>接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。  </p>
<p>重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。  </p>
<blockquote>
<p>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。  </p>
</blockquote>
<pre><code>import lombok.Data;  
  
import java.util.Arrays;  
import java.util.PriorityQueue;  
  
/**  
 * @author https://github.com/yanglbme */@Data  
public class DataWithSource implements Comparable&lt;DataWithSource&gt; &#123;  
    /**     * 数值  
     */    private int value;  
    /**     * 记录数值来源的数组  
     */    private int source;  
    /**     * 记录数值在数组中的索引  
     */    private int index;  
    public DataWithSource(int value, int source, int index) &#123;        this.value = value;        this.source = source;        this.index = index;    &#125;  
    /**     *     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改  
     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆  
     */    @Override    public int compareTo(DataWithSource o) &#123;        return Integer.compare(o.getValue(), this.value);    &#125;&#125;  
  
class Test &#123;  
    public static int[] getTop(int[][] data) &#123;        int rowSize = data.length;        int columnSize = data[0].length;  
        // 创建一个columnSize大小的数组，存放结果  
        int[] result = new int[columnSize];  
        PriorityQueue&lt;DataWithSource&gt; maxHeap = new PriorityQueue&lt;&gt;();        for (int i = 0; i &lt; rowSize; ++i) &#123;            // 将每个数组的最大一个元素放入堆中  
            DataWithSource d = new DataWithSource(data[i][0], i, 0);            maxHeap.add(d);        &#125;  
        int num = 0;        while (num &lt; columnSize) &#123;            // 删除堆顶元素  
            DataWithSource d = maxHeap.poll();            result[num++] = d.getValue();            if (num &gt;= columnSize) &#123;                break;            &#125;  
            d.setValue(data[d.getSource()][d.getIndex() + 1]);            d.setIndex(d.getIndex() + 1);            maxHeap.add(d);        &#125;        return result;  
    &#125;  
    public static void main(String[] args) &#123;        int[][] data = &#123;                &#123;29, 17, 14, 2, 1&#125;,                &#123;19, 17, 16, 15, 6&#125;,                &#123;30, 25, 20, 14, 5&#125;,        &#125;;  
        int[] top = getTop(data);        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]    &#125;&#125;  
</code></pre>
<h4 id="方法总结-8"><a href="#方法总结-8" class="headerlink" title="方法总结"></a>方法总结</h4><p>求 TopK，不妨考虑一下堆排序？</p>
<h1 id="离职前准备"><a href="#离职前准备" class="headerlink" title="离职前准备"></a>离职前准备</h1><h3 id="离职个人信息清理"><a href="#离职个人信息清理" class="headerlink" title="离职个人信息清理"></a>离职个人信息清理</h3><p>系统重置   个人文件夹清理，文档，personxx，代码空间space，   浏览器下线，浏览器浏览记录、书签、保存的密码清理   系统用户下线，不设置密码   qq，微信等常用app卸载   回收站清空  </p>
<h3 id="要离职怎么说"><a href="#要离职怎么说" class="headerlink" title="要离职怎么说"></a>要离职怎么说</h3><p>慎选理由   不能说薪资   如果加钱你怎么办，你走说你贪得无厌，你不走也不行。如果传到未来新公司，影响不好   不能说同事不好   主管同事不会因为你的评价而改变性格，而只会改变对你的评价。比如说你挑剔，不好管理，要求太多，如果憋不住了非要说可以比较温和的，比如，我不太适应该公司的文化，大家都比较内敛，沟通比较少，而我这个人比较外向，个性不太一样。   告知去处   如果说了去什么，后面发现你没去，别人会认为欺骗，原来的人际会影响   不要具体到xx公司多少钱，避免老总借助影响力打压你   表示感谢(注意，感激是为了体现职场的专业态度，不是为了和上司拉感情，工作是工作，感情是感情，不要因为感情而拖泥带水。这也是对自己和公司的负责。)   谈谈收获   谈谈成长   关系融洽还可以坦诚问问未来发展和自己的不足   关系不融洽，指责如果不够忠诚，表示遗憾，不要争辩，立场不同  </p>
<h3 id="离职理由"><a href="#离职理由" class="headerlink" title="离职理由"></a>离职理由</h3><p>为啥要说加班多？你可以说上一份工作对你的成长来说已经没有挑战了，都是日复一日的重复工作，所以想要找一份更有挑战性的工作。   上一份工作自身的上升发展空间不大&#x2F;跟我自己的职业规划不适配，想跳出舒适圈，贵公司的这个职位有发展空间   理由:之前的公司工资待遇低 这个理由对我来说是真实的。而且我觉得这个理由也能暗示面试的这家公司如果自己能给的待遇还不如面试者上家公司多，那就别再面了，不要浪费彼此的时间，赶紧886  </p>
<h3 id="离职原因有哪些不得罪人的话术"><a href="#离职原因有哪些不得罪人的话术" class="headerlink" title="离职原因有哪些不得罪人的话术?"></a>离职原因有哪些不得罪人的话术?</h3><p>1.实际原因:原单位钱太少   离职原因:我认为我自己已经具备了一定的积累,希望可以迈向一个新的台阶。   2.实际原因:跟同事处不来   离职原因:我很重视平台的发展,我认为一个人才只有放在合适的平台才能够最大程度的发挥出自己的才干。   3.实际原因:有个傻X领导   离职原因:虽然我已经有相当的经验和技能,但仍然希望能够拓宽自己的知识面，进行更深入的学习和实践。   4.实际原因:傻X管理制度太多   离职原因:贵公司所推崇的人性化管理“非常符合我对工作环境的预期，我也相信在这样的环境.中，我能够发挥出更大的主观能动性。   5.实际原因:太忙了   离职原因:相比于低效重复的工作进度，我更认同高效高质的工作模式   6实际原因:太闲了   离职原因:我是一个不满足于现状的人，我认为年轻人不应该满足于安乐的环境,应该随时具有努力和奋斗的觉悟。</p>
<h2 id="心理按摩"><a href="#心理按摩" class="headerlink" title="心理按摩"></a>心理按摩</h2><p>总有人在网上抱怨，说自己专科学历，找工作受歧视，职场对低学历的人容忍度低。</p>
<p>我不由得想起了我认识的一个人。</p>
<p>他是我在百度的时候我认识的一个前端开发。</p>
<p>大专学历，技术过硬，工作三年的过程中读的专升本，后来进的百度。</p>
<p>再后来读的北航在职硕士，业余时学英语，在食堂练英文刷leetcode。</p>
<p>三年后，拿到google offer，base海外。</p>
<p>有些时候我们经常会抱怨社会的不公平，抱怨自己的title不够好，学历不够高。</p>
<p>但是如果我们把自己标签已经定义成这样不堪的自己，这个社会又怎么能跨过你的标签，去挖掘你真实的能力。</p>
<p>要么扔掉你的标签，自信的走向职场；要么重塑你的标签，让职场来pick你。</p>
<p>程序员搞技术一定要抓住自己的职场黄金10年，25~35岁，这是一生中最重要的阶段，能走多远走多远，能爬多高爬多高，一点都不能浪费。</p>
<p>程序员同时也不要被技术所局限，不是所有的人都能一直干到退休做技术。认清自己的定位，以及要走的路，鱼哥身边有不少赶在35之前上岸公务员，上岸国企，上岸其他领域，都是一些不错的路。</p>
<p>只要有资料，有视频，一般不太可能出现学不会的东西。除非百度不到，网上所有地方都没有关于这块的资料。这种确实不好学，只能通过工作中慢慢实验总结学习</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cjchn.github.io">CJ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cjchn.github.io/posts/20231019034827-40769f33.html">https://cjchn.github.io/posts/20231019034827-40769f33.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cjchn.github.io" target="_blank">CJ's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%93%E9%A2%98/">专题</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20231019060701-4a02d4e8.html" title="青年一派卡"><img class="cover" src="https://vip.helloimg.com/images/2023/12/15/o7LNut.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">青年一派卡</div></div></a></div><div class="next-post pull-right"><a href="/posts/20231019032459-fec99276.html" title="消息队列"><img class="cover" src="https://vip.helloimg.com/images/2023/12/15/o7Lm9z.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">消息队列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/20231019032459-fec99276.html" title="消息队列"><img class="cover" src="https://vip.helloimg.com/images/2023/12/15/o7Lm9z.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-19</div><div class="title">消息队列</div></div></a></div><div><a href="/posts/20231018090328-c0add594.html" title="vue"><img class="cover" src="https://vip.helloimg.com/images/2023/12/15/o7LTkK.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-18</div><div class="title">vue</div></div></a></div><div><a href="/posts/20230920063041-a6ee4416.html" title="常用软件探究"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-20</div><div class="title">常用软件探究</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://imgcdn.319226.xyz/202401041503387.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CJ</div><div class="author-info__description">保持正念，相信自己会越来越好</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2675851908&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #24292e;"></i></a><a class="social-icon" href="https://github.com/cjchn" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/302998641" target="_blank" title="视频"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://tgph.319226.xyz/" target="_blank" title="图床"><i class="fa-solid fa-image" style="color: #24292e;"></i></a><a class="social-icon" href="https://onedrive.319226.xyz/" target="_blank" title="云盘"><i class="fa-solid fa-cloud" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%BE%85%E6%8A%80%E6%9C%AF%E9%A2%98%E7%9A%84%E9%9D%A2%E8%AF%95%E6%80%9D%E8%B7%AF"><span class="toc-number">1.0.1.</span> <span class="toc-text">对待技术题的面试思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">如何设计一个高并发系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">系统拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQ"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">MQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">ElasticSearch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-CAP-%E5%AE%9A%E7%90%86-P-%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">分布式系统 CAP 定理 P 代表什么含义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CAP-%E5%AE%9A%E7%90%86%EF%BC%88CAP-theorem%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是 CAP 定理（CAP theorem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7%EF%BC%88Partition-tolerance%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">分区容错性（Partition tolerance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84-CAP-%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">几个常用的 CAP 框架对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Eureka"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Eureka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Zookeeper"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Zookeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consul"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Consul</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">分布式锁如何设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">Redis 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%9C%80%E6%99%AE%E9%80%9A%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">Redis 最普通的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedLock-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">RedLock 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zk-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">zk 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C-zk-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.5.</span> <span class="toc-text">redis 分布式锁和 zk 分布式锁的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E6%96%B9%E6%A1%88-XA-%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">两阶段提交方案&#x2F;XA 方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCC-%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.2.</span> <span class="toc-text">TCC 方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Saga-%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">Saga 方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">本地消息表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.5.</span> <span class="toc-text">可靠消息最终一致性方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.6.</span> <span class="toc-text">最大努力通知方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%BB%AC%E5%85%AC%E5%8F%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">你们公司是如何处理分布式事务的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.5.</span> <span class="toc-text">分布式会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%97%B6%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-Session-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">集群部署时的分布式 Session 如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%B8%8D%E7%94%A8-Session"><span class="toc-number">1.5.2.</span> <span class="toc-text">完全不用 Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat-Redis"><span class="toc-number">1.5.3.</span> <span class="toc-text">Tomcat + Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Session-Redis"><span class="toc-number">1.5.4.</span> <span class="toc-text">Spring Session + Redis</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E6%B5%81%EF%BC%9F%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">如何限流？在工作中是怎么做的？说一下具体的实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%99%90%E6%B5%81"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">限流方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Leaky-Bucket-%E6%BC%8F%E6%A1%B6"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">Leaky Bucket 漏桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Token-Bucket-%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">Token Bucket 令牌桶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">工作中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-cloud-gateway"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">spring cloud gateway</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinel"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">sentinel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%94%E6%96%AD"><span class="toc-number">1.7.</span> <span class="toc-text">熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%86%94%E6%96%AD%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">如何进行熔断？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E6%A1%86%E6%9E%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">熔断框架都有哪些？具体实现原理知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9FSentinel-%E8%BF%98%E6%98%AF-Hystrix%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">如何做技术选型？Sentinel 还是 Hystrix？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AF%B4%E6%98%8E"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">总体说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">共同特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.3.2.1.</span> <span class="toc-text">1. 资源模型和执行模型上的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9A%94%E7%A6%BB%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">2. 隔离设计上的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">3. 熔断降级的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E6%97%B6%E6%8C%87%E6%A0%87%E7%BB%9F%E8%AE%A1%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.3.5.</span> <span class="toc-text">4. 实时指标统计实现的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sentinel-%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.4.</span> <span class="toc-text">Sentinel 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1. 轻量级、高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2. 流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">3. 系统负载保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E5%92%8C%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">4. 实时监控和控制面板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%94%9F%E6%80%81"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">5. 生态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.7.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">Spring Cloud 微服务架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">什么是微服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E7%8B%AC%E7%AB%8B%E9%80%9A%E8%AE%AF%E7%9A%84"><span class="toc-number">1.8.2.</span> <span class="toc-text">微服务之间是如何独立通讯的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#REST-HTTP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.2.1.1.</span> <span class="toc-text">REST HTTP 协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RPC-TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.2.1.2.</span> <span class="toc-text">RPC TCP 协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.8.2.2.1.</span> <span class="toc-text">消息中间件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">微服务技术栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">微服务开发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">微服务注册发现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Eureka-1"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">Eureka</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Zookeeper-1"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">Zookeeper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Zookeeper-%E5%92%8C-Eureka-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">Zookeeper 和 Eureka 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">微服务配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Disconf"><span class="toc-number">1.8.3.3.1.</span> <span class="toc-text">Disconf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SpringCloudConfig"><span class="toc-number">1.8.3.3.2.</span> <span class="toc-text">SpringCloudConfig</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Apollo"><span class="toc-number">1.8.3.3.3.</span> <span class="toc-text">Apollo</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">权限认证</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-Security"><span class="toc-number">1.8.3.4.1.</span> <span class="toc-text">Spring Security</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Apache-Shiro"><span class="toc-number">1.8.3.4.2.</span> <span class="toc-text">Apache Shiro</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.8.3.5.</span> <span class="toc-text">批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Spring-Batch"><span class="toc-number">1.8.3.5.1.</span> <span class="toc-text">Spring Batch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.8.3.6.</span> <span class="toc-text">定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Quartz"><span class="toc-number">1.8.3.6.1.</span> <span class="toc-text">Quartz</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.3.7.</span> <span class="toc-text">微服务调用 (协议)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rest"><span class="toc-number">1.8.3.7.1.</span> <span class="toc-text">Rest</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RPC"><span class="toc-number">1.8.3.7.2.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gRPC"><span class="toc-number">1.8.3.7.3.</span> <span class="toc-text">gRPC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RMI"><span class="toc-number">1.8.3.7.4.</span> <span class="toc-text">RMI</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8"><span class="toc-number">1.8.3.8.</span> <span class="toc-text">服务接口调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Feign-HTTP"><span class="toc-number">1.8.3.8.1.</span> <span class="toc-text">Feign(HTTP)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="toc-number">1.8.3.9.</span> <span class="toc-text">服务熔断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Hystrix"><span class="toc-number">1.8.3.9.1.</span> <span class="toc-text">Hystrix</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sentinel"><span class="toc-number">1.8.3.9.2.</span> <span class="toc-text">Sentinel</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.8.3.10.</span> <span class="toc-text">服务的负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Ribbon"><span class="toc-number">1.8.3.10.1.</span> <span class="toc-text">Ribbon</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx"><span class="toc-number">1.8.3.10.2.</span> <span class="toc-text">Nginx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nginx-%E4%B8%8E-Ribbon-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.3.10.3.</span> <span class="toc-text">Nginx 与 Ribbon 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.8.3.11.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Kafka"><span class="toc-number">1.8.3.11.1.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">1.8.3.11.2.</span> <span class="toc-text">RabbitMQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RocketMQ"><span class="toc-number">1.8.3.11.3.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#activeMQ"><span class="toc-number">1.8.3.11.4.</span> <span class="toc-text">activeMQ</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86-elk"><span class="toc-number">1.8.3.12.</span> <span class="toc-text">日志采集 (elk)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Elasticsearch"><span class="toc-number">1.8.3.12.1.</span> <span class="toc-text">Elasticsearch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Logstash"><span class="toc-number">1.8.3.12.2.</span> <span class="toc-text">Logstash</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kibana"><span class="toc-number">1.8.3.12.3.</span> <span class="toc-text">Kibana</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API-%E7%BD%91%E5%85%B3"><span class="toc-number">1.8.3.13.</span> <span class="toc-text">API 网关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Zuul"><span class="toc-number">1.8.3.13.1.</span> <span class="toc-text">Zuul</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7"><span class="toc-number">1.8.3.14.</span> <span class="toc-text">服务监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Zabbix"><span class="toc-number">1.8.3.14.1.</span> <span class="toc-text">Zabbix</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Nagios"><span class="toc-number">1.8.3.14.2.</span> <span class="toc-text">Nagios</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Metrics"><span class="toc-number">1.8.3.14.3.</span> <span class="toc-text">Metrics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.8.3.14.4.</span> <span class="toc-text">服务链路追踪</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Zipkin"><span class="toc-number">1.8.3.14.5.</span> <span class="toc-text">Zipkin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Brave"><span class="toc-number">1.8.3.14.6.</span> <span class="toc-text">Brave</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.3.15.</span> <span class="toc-text">数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.8.3.15.1.</span> <span class="toc-text">关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#MySql"><span class="toc-number">1.8.3.15.1.1.</span> <span class="toc-text">MySql</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Oracle"><span class="toc-number">1.8.3.15.1.2.</span> <span class="toc-text">Oracle</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MsSQL"><span class="toc-number">1.8.3.15.1.3.</span> <span class="toc-text">MsSQL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PostgreSql"><span class="toc-number">1.8.3.15.1.4.</span> <span class="toc-text">PostgreSql</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.8.3.15.2.</span> <span class="toc-text">非关系型数据库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mongodb"><span class="toc-number">1.8.3.15.3.</span> <span class="toc-text">Mongodb</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Elasticsearch-1"><span class="toc-number">1.8.3.15.4.</span> <span class="toc-text">Elasticsearch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98-1"><span class="toc-number">1.8.3.16.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redis"><span class="toc-number">1.8.3.16.1.</span> <span class="toc-text">redis</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8-1"><span class="toc-number">1.8.3.17.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ShardingSphere"><span class="toc-number">1.8.3.17.1.</span> <span class="toc-text">ShardingSphere</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mycat"><span class="toc-number">1.8.3.17.2.</span> <span class="toc-text">Mycat</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2"><span class="toc-number">1.8.3.18.</span> <span class="toc-text">服务部署</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Docker"><span class="toc-number">1.8.3.18.1.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Jenkins"><span class="toc-number">1.8.3.18.2.</span> <span class="toc-text">Jenkins</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Kubernetes-K8s"><span class="toc-number">1.8.3.18.3.</span> <span class="toc-text">Kubernetes(K8s)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mesos"><span class="toc-number">1.8.3.18.4.</span> <span class="toc-text">Mesos</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.8.4.</span> <span class="toc-text">微服务治理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">服务的注册和发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.4.4.</span> <span class="toc-text">配置管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">1.8.4.5.</span> <span class="toc-text">容错和服务降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.4.6.</span> <span class="toc-text">服务依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%96%87%E6%A1%A3"><span class="toc-number">1.8.4.7.</span> <span class="toc-text">服务文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.4.8.</span> <span class="toc-text">服务安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.4.9.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.4.10.</span> <span class="toc-text">自动化测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8A%E7%BA%BF"><span class="toc-number">1.8.4.11.</span> <span class="toc-text">服务上线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">1.8.4.12.</span> <span class="toc-text">兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92"><span class="toc-number">1.8.4.13.</span> <span class="toc-text">服务编排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.4.14.</span> <span class="toc-text">资源调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92"><span class="toc-number">1.8.4.15.</span> <span class="toc-text">容量规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%BB%84%E4%BB%B6-Eureka-%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">服务发现组件 Eureka 的几个主要调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Eureka-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">Eureka 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%88Eureka-Server%EF%BC%89"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">服务注册中心（Eureka Server）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%EF%BC%88Register%EF%BC%89"><span class="toc-number">1.8.5.3.1.</span> <span class="toc-text">服务注册（Register）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%EF%BC%88Renew%EF%BC%89"><span class="toc-number">1.8.5.3.2.</span> <span class="toc-text">服务续约（Renew）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%EF%BC%88Cancel%EF%BC%89"><span class="toc-number">1.8.5.3.3.</span> <span class="toc-text">服务下线（Cancel）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%89%94%E9%99%A4%EF%BC%88Eviction%EF%BC%89"><span class="toc-number">1.8.5.3.4.</span> <span class="toc-text">服务剔除（Eviction）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%88Service-Provider%EF%BC%89"><span class="toc-number">1.8.5.4.</span> <span class="toc-text">服务提供者（Service Provider）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%EF%BC%88Register%EF%BC%89-1"><span class="toc-number">1.8.5.4.1.</span> <span class="toc-text">服务注册（Register）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6%EF%BC%88Renew%EF%BC%89-1"><span class="toc-number">1.8.5.4.2.</span> <span class="toc-text">服务续约（Renew）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%EF%BC%88Cancel%EF%BC%89-1"><span class="toc-number">1.8.5.4.3.</span> <span class="toc-text">服务下线（Cancel）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Service-Consumer%EF%BC%89"><span class="toc-number">1.8.5.5.</span> <span class="toc-text">服务消费者（Service Consumer）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%88Fetch%EF%BC%89"><span class="toc-number">1.8.5.5.1.</span> <span class="toc-text">获取服务列表（Fetch）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%88Update%EF%BC%89"><span class="toc-number">1.8.5.5.2.</span> <span class="toc-text">更新服务列表（Update）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.8.5.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">海量数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%A7%E9%87%8F%E7%9A%84-URL-%E4%B8%AD%E6%89%BE%E5%87%BA%E7%9B%B8%E5%90%8C%E7%9A%84-URL%EF%BC%9F"><span class="toc-number">1.9.1.</span> <span class="toc-text">如何从大量的 URL 中找出相同的 URL？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="toc-number">1.9.1.2.1.</span> <span class="toc-text">1. 分治策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.9.1.2.2.</span> <span class="toc-text">2. 前缀树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">方法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="toc-number">1.9.1.3.1.</span> <span class="toc-text">分治策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.9.1.3.2.</span> <span class="toc-text">前缀树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E9%AB%98%E9%A2%91%E8%AF%8D%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">如何从大量数据中找出高频词？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E6%9F%90%E4%B8%80%E5%A4%A9%E8%AE%BF%E9%97%AE%E7%99%BE%E5%BA%A6%E7%BD%91%E7%AB%99%E6%9C%80%E5%A4%9A%E7%9A%84-IP%EF%BC%9F"><span class="toc-number">1.9.3.</span> <span class="toc-text">如何找出某一天访问百度网站最多的 IP？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%A7%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.4.</span> <span class="toc-text">如何在大量的数据中找出不重复的整数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">1.9.4.2.1.</span> <span class="toc-text">方法一分治法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="toc-number">1.9.4.2.2.</span> <span class="toc-text">方法二位图法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%A7%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9F"><span class="toc-number">1.9.5.</span> <span class="toc-text">如何在大量的数据中判断一个数是否存在？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">1.9.5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.9.5.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">1.9.5.2.1.</span> <span class="toc-text">方法一：分治法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="toc-number">1.9.5.2.2.</span> <span class="toc-text">方法二：位图法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.9.5.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%B2%EF%BC%9F"><span class="toc-number">1.9.6.</span> <span class="toc-text">如何查询最热门的查询串？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95-1"><span class="toc-number">1.9.6.2.1.</span> <span class="toc-text">方法一：分治法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AHashMap-%E6%B3%95"><span class="toc-number">1.9.6.2.2.</span> <span class="toc-text">方法二：HashMap 法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E5%89%8D%E7%BC%80%E6%A0%91%E6%B3%95"><span class="toc-number">1.9.6.2.3.</span> <span class="toc-text">方法三：前缀树法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.9.6.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%90%8C%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.7.</span> <span class="toc-text">如何统计不同电话号码的个数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">1.9.7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.9.7.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.9.7.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E-5-%E4%BA%BF%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.8.</span> <span class="toc-text">如何从 5 亿个数中找出中位数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-7"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8F%8C%E5%A0%86%E6%B3%95"><span class="toc-number">1.9.8.2.1.</span> <span class="toc-text">方法一：双堆法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">1.9.8.2.2.</span> <span class="toc-text">方法二：分治法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-6"><span class="toc-number">1.9.8.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8C%89%E7%85%A7-query-%E7%9A%84%E9%A2%91%E5%BA%A6%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.9.9.</span> <span class="toc-text">如何按照 query 的频度排序？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="toc-number">1.9.9.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-8"><span class="toc-number">1.9.9.2.</span> <span class="toc-text">解答思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AHashMap-%E6%B3%95"><span class="toc-number">1.9.9.2.1.</span> <span class="toc-text">方法一：HashMap 法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%88%86%E6%B2%BB%E6%B3%95-1"><span class="toc-number">1.9.9.2.2.</span> <span class="toc-text">方法二：分治法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-7"><span class="toc-number">1.9.9.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E6%8E%92%E5%90%8D%E5%89%8D-500-%E7%9A%84%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.10.</span> <span class="toc-text">如何找出排名前 500 的数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="toc-number">1.9.10.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E6%80%9D%E8%B7%AF-9"><span class="toc-number">1.9.10.2.</span> <span class="toc-text">解答思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93-8"><span class="toc-number">1.9.10.3.</span> <span class="toc-text">方法总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A6%BB%E8%81%8C%E5%89%8D%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">离职前准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E8%81%8C%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E6%B8%85%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">离职个人信息清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E7%A6%BB%E8%81%8C%E6%80%8E%E4%B9%88%E8%AF%B4"><span class="toc-number">2.0.2.</span> <span class="toc-text">要离职怎么说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E8%81%8C%E7%90%86%E7%94%B1"><span class="toc-number">2.0.3.</span> <span class="toc-text">离职理由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E8%81%8C%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%BE%97%E7%BD%AA%E4%BA%BA%E7%9A%84%E8%AF%9D%E6%9C%AF"><span class="toc-number">2.0.4.</span> <span class="toc-text">离职原因有哪些不得罪人的话术?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%83%E7%90%86%E6%8C%89%E6%91%A9"><span class="toc-number">2.1.</span> <span class="toc-text">心理按摩</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/20231229062330-416f6fc3.html" title="NewPost">NewPost</a><time datetime="2023-12-29T06:23:30.000Z" title="发表于 2023-12-29 14:23:30">2023-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/20231222053433-b84b57db.html" title="Html">Html</a><time datetime="2023-12-22T05:34:33.000Z" title="发表于 2023-12-22 13:34:33">2023-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/20231215080353-36687561.html" title="关于音乐">关于音乐</a><time datetime="2023-12-15T08:03:53.000Z" title="发表于 2023-12-15 16:03:53">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20231211023548-74516b02.html" title="office"><img src="https://vip.helloimg.com/images/2023/12/15/o7AvhR.md.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="office"/></a><div class="content"><a class="title" href="/posts/20231211023548-74516b02.html" title="office">office</a><time datetime="2023-12-11T02:35:48.000Z" title="发表于 2023-12-11 10:35:48">2023-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/20231207051738-3fb16ec5.html" title="人大金仓">人大金仓</a><time datetime="2023-12-07T05:17:38.000Z" title="发表于 2023-12-07 13:17:38">2023-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By CJ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><span class="scroll-percent"></span><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.2/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><div class="aplayer no-destroy" data-id="2024518101" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false" data-mini="true"> </div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//npm.elemecdn.com/penndu@1.0.0/bsz.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.17.1/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.56.1/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>